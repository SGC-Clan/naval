<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sandbox.Game</name>
    </assembly>
    <members>
        <member name="T:Sandbox.GameAssemblyManager">
            <summary>
            Handles the storage and loading of assemblies sent from the server via string tables
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.Init">
            <summary>
            Called on Game Loop Init
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.ClientSignonFull">
            <summary>
            The client has ended the loading and downloading session and is now ready to enter the server
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.Shutdown">
            <summary>
            Called on Game Loop Deactivate
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.OnAssemblyFromServer(System.Int32)">
            <summary>
            Called by the string table when an assembly is recieved/added
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.TestAccessControl(System.IO.Stream,System.IO.Stream)">
            <summary>
            Make sure we should be able to load this dll
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.OnAssembly(System.String,System.IO.Stream,System.IO.Stream)">
            <summary>
            Assembly is ready to load. Will return false on fail.
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.ForceLoadCompiler(Sandbox.Compiler)">
            <summary>
            Called by the menu to load its dlls
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.SetSwapNeeded">
            <summary>
            When an assembly is loaded we call this. We want to defer the swap
            incase other assemblies are loaded in the meantime, so we can swap 
            just once instead of once per assembly.
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.Tick">
            <summary>
            Should be called every frame
            </summary>
        </member>
        <member name="P:Sandbox.Asset.Path">
            <summary>
            Full path to the asset
            </summary>
        </member>
        <member name="P:Sandbox.Asset.Name">
            <summary>
            Name of the asset, usually comes from the filename
            </summary>
        </member>
        <member name="M:Sandbox.SoundEvent.PostLoad">
            <summary>
            Called after the asset is loaded from disk
            </summary>
        </member>
        <member name="M:Sandbox.Surface.PostLoad">
            <summary>
            Called after the asset is loaded from disk
            </summary>
        </member>
        <member name="M:Sandbox.Surface.PostReload">
            <summary>
            Called after the asset is reloaded from disk
            </summary>
        </member>
        <member name="M:Sandbox.Surface.FindByIndex(System.Int32)">
            <summary>
            Find a surface by its index in the array. This is the fastest way to lookup, so it's
            passed from things like Traces since the index is going to be the same. It's important to
            know that this index shouldn't be saved or networked because it could differ between loads or clients.
            Instead send the name hash and look up using that.
            </summary>
        </member>
        <member name="M:Sandbox.Surface.FindByName(System.String)">
            <summary>
            Returns a Surface from its name, or null
            </summary>
            <param name="name">The name of a surface property to look up</param>
            <returns>The surface with given name, or null if such surface property doesn't exist</returns>
        </member>
        <member name="T:Sandbox.Library">
            <summary>
            Allows the registration/creation of classes by name, in a generic way.
            Also remembers class by assembly name, so we can gracefully handle hotloading.
            </summary>
        </member>
        <member name="M:Sandbox.Library.AddAssembly(System.Reflection.Assembly,System.Type[])">
            <summary>
            Called on all loaded assemblies to gather classes with ClassLibrary attributes
            </summary>
        </member>
        <member name="M:Sandbox.Library.ProcessType(System.Type,System.Reflection.Assembly)">
            <summary>
            Process this type, add it to the library if it has the right tags
            </summary>
        </member>
        <member name="M:Sandbox.Library.EntrolType(System.Type,System.Reflection.Assembly,Sandbox.LibraryAttribute)">
            <summary>
            Should this class be automatically added to the class library, even if it isn't tagged with an attribute
            </summary>
        </member>
        <member name="M:Sandbox.Library.ShouldAutomaticallyEntrolType(System.Type)">
            <summary>
            Should this class be automatically added to the class library, even if it isn't tagged with an attribute
            </summary>
        </member>
        <member name="M:Sandbox.Library.RemoveAssembly(System.Reflection.Assembly)">
            <summary>
            Called when an assembly is being removed
            </summary>
        </member>
        <member name="M:Sandbox.Library.Create``1(System.String,System.Boolean)">
            <summary>
            Create a class by name. Will return null if class is wrong type or not found.
            </summary>
        </member>
        <member name="M:Sandbox.Library.TryCreate``1(System.Int32)">
            <summary>
            Create a class by identifier. Will return null if class is wrong type or not found.
            </summary>
        </member>
        <member name="M:Sandbox.Library.Create``1(System.Type)">
            <summary>
            Create a class by type. Will return null if class is wrong type or not found.
            </summary>
        </member>
        <member name="M:Sandbox.Library.GetAll">
            <summary>
            Returns all class registrations.
            </summary>
        </member>
        <member name="M:Sandbox.Library.GetAll``1">
            <summary>
            Get all types that are derived from type
            </summary>
        </member>
        <member name="M:Sandbox.Library.GetAttribute(System.String)">
            <summary>
            Find an attribute from a name
            </summary>
        </member>
        <member name="M:Sandbox.Library.GetAllAttributes``1">
            <summary>
            Get all library attributes that are attached to type
            </summary>
        </member>
        <member name="M:Sandbox.Library.GetAttributes``1">
            <summary>
            Get custom attributes that are derived from type
            </summary>
        </member>
        <member name="M:Sandbox.Library.Get``1(System.String)">
            <summary>
            Given the name and base type, return the type (or null if it doesn't exist)
            </summary>
        </member>
        <member name="M:Sandbox.Library.Exists``1(System.String)">
            <summary>
            Returns true if this type exists
            </summary>
        </member>
        <member name="M:Sandbox.Library.GetAttribute(System.Type)">
            <summary>
            Returns all class registrations.
            </summary>
        </member>
        <member name="T:Sandbox.LibraryClass">
            <summary>
            Every class that is derived from this is automatically added to the library. 
            If they have a [Library] attribute we use that, if not we create an empty one.
            </summary>
        </member>
        <member name="P:Sandbox.LibraryClass.LibraryClassIdentifier">
            <summary>
            This is an int representing this class. It can be used with Library to
            get the class type. It's also networkable, so can represent the class
            type over the network.
            </summary>
        </member>
        <member name="P:Sandbox.LibraryClass.ClassInfo">
            <summary>
            We really shouldn't be using the attribute for this, it feels kind of dumb
            </summary>
        </member>
        <member name="M:Sandbox.NetworkComponent.ClearNetworkTables">
            <summary>
            Wipe the network table and clear the child variables, 
            so they can't read/write even if they try.
            </summary>
        </member>
        <member name="M:Sandbox.PropertyClass.SetProperty(System.String,System.String)">
            <summary>
            Sets a property on this class. For a property to be settable you should have marked it with [Prop] (or one of its children)
            </summary>
        </member>
        <member name="M:Sandbox.Cookie.SetString(System.String,System.String)">
            <summary>
            Set a cookie to be stored between sessions. The cookie will expire one month
            from when it was set.
            </summary>
        </member>
        <member name="M:Sandbox.Cookie.GetString(System.String,System.String)">
            <summary>
            Get a stored session cookie.
            </summary>
        </member>
        <member name="M:Sandbox.Cookie.Get``1(System.String,``0)">
            <summary>
            Load JSON encodable data from cookies
            </summary>
        </member>
        <member name="M:Sandbox.Cookie.Set``1(System.String,``0)">
            <summary>
            Set JSON encodable object to data
            </summary>
        </member>
        <member name="P:Sandbox.Voice.SampleRate">
            <summary>
            Available clientside, this is the sample rate that we're encoding our voice at
            </summary>
        </member>
        <member name="P:Sandbox.Voice.IsRecording">
            <summary>
            Returns true if your voice is actually recording. This means you're pressing your PTT key (or have always talk on)
            and you're actually making noise that is being recorded and sent to other computers.
            </summary>
        </member>
        <member name="M:Sandbox.Voice.Decode(System.Span{System.Byte},System.Span{System.Byte})">
            <summary>
            Decode the passed data. Returns true on success and gives out a data and size.
            </summary>
        </member>
        <member name="M:Sandbox.Voice.Play(System.UInt64,System.Span{System.Byte},System.Boolean)">
            <summary>
            Play this voice data
            </summary>
        </member>
        <member name="M:Sandbox.Voice.ComputeVoiceLevel(System.Int16*,System.Int32)">
            <summary>
            Go through the data and try to work out the voice level
            </summary>
        </member>
        <member name="M:Sandbox.Voice.PlayVoiceInternal(System.Span{System.Byte},System.UInt64)">
            <summary>
            Actually send the voice data to the engine for playback.
            </summary>
        </member>
        <member name="P:Sandbox.ConsoleSystem.Caller">
            <summary>
            Returns the player who is calling the command. This will be null
            if the command is being called via rcon, or triggered directly
            on the server.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.HasCallerGotPermission">
            <summary>
            Does this player have permission to do run commands that need permission
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.Build(System.String,System.Object[])">
            <summary>
            Given a command and parameters, build a coherent command
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.FindManagedValue(System.String,System.String)">
            <summary>
            Find a managed convar value
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.SetValue(System.String,System.Object)">
            <summary>
            Used by [SetValue] etc
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.GetValue(System.String,System.String)">
            <summary>
            Get a convar value as a string
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.AddAssembly(System.Reflection.Assembly)">
            <summary>
            Add this assembly to the console library, which will scan it for console commands and make them available.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.AddConVar(Sandbox.GameConVar)">
            <summary>
            Add this convar to the library. Any existing commands named the same will be over-written.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.RemoveAssembly(System.Reflection.Assembly)">
            <summary>
            Remove this assembly and its console commands 
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.AddCommand(Sandbox.Command)">
            <summary>
            Add this command to the library. Any existing commands named the same will be over-written.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.Run(Sandbox.ConsoleCommand)">
            <summary>
            Actually do the business of trying to run a command. Will return (not throw) an exception
            object if an exception is thrown of command isn't found.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.RunCommandFromInputBuffer(System.String)">
            <summary>
            A command has come from a key bind. Return false if we don't handle it.
            </summary>
        </member>
        <member name="M:Sandbox.ContextInterface.PostCreateInterface">
            <summary>
            Called right after the interface between us and c++ is created
            </summary>
        </member>
        <member name="M:Sandbox.ContextInterface.OnShutdown">
            <summary>
            The current game has shut down
            </summary>
        </member>
        <member name="M:Sandbox.ContextInterface.InitGamemodeData(System.String)">
            <summary>
            Create the data folders and the basefilesystem's for the gamemode folder
            </summary>
        </member>
        <member name="M:Sandbox.MenuInterface.InitAsync">
            <summary>
            Wait for compile to finish and then load the menu
            </summary>
        </member>
        <member name="M:Sandbox.MenuInterface.DispatchCommand(System.String,System.String,System.Int64,System.Int32)">
            <summary>
            A command has been run. We have to route it like this from the client instance.
            </summary>
        </member>
        <member name="M:Sandbox.ServerInterface.OnAddonsCompiled(Sandbox.Compiler[])">
            <summary>
            Called when a batch of compilers are compiled.
            </summary>
        </member>
        <member name="M:Sandbox.ServerInterface.AddAssemblyTransport(Sandbox.Compiler)">
            <summary>
            Add this assembly to the string table, which will send it to the client
            </summary>
        </member>
        <member name="M:Sandbox.ServerInterface.ServerLoadStart">
            <summary>
            Server is starting to load, kick it off
            </summary>
        </member>
        <member name="M:Sandbox.ServerInterface.ServerLoadLoop">
            <summary>
            Server is loading, return true to finish loading
            </summary>
        </member>
        <member name="M:Sandbox.Decals.Place(Sandbox.Material,Sandbox.Entity,System.Int32,Vector3,Vector3,Rotation)">
            <summary>
            Place a decal on an entity
            </summary>
        </member>
        <member name="M:Sandbox.Decals.Place(Sandbox.Material,Vector3,Vector3,Rotation)">
            <summary>
            Place a decal on the world
            </summary>
        </member>
        <member name="M:Sandbox.Particles.Create(System.String)">
            <summary>
            Create a particle system by name
            </summary>
        </member>
        <member name="M:Sandbox.Particles.Create(System.String,Vector3)">
            <summary>
            Create a particle system by name at a world position
            </summary>
        </member>
        <member name="M:Sandbox.Particles.Create(System.String,Sandbox.Entity,System.String,System.Boolean)">
            <summary>
            Create a particle system by name attached to an entity
            </summary>
        </member>
        <member name="M:Sandbox.Particles.Dispose">
            <summary>
            Dispose of this particle system
            </summary>
        </member>
        <member name="M:Sandbox.Particles.Destroy(System.Boolean)">
            <summary>
            Destroy this particle system
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetPosition(System.Int32,Vector3)">
            <summary>
            Set the position of this particle system
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetForward(System.Int32,Vector3)">
            <summary>
            Set the forward vector of this particle system
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetEntity(System.Int32,Sandbox.Entity,System.Boolean)">
            <summary>
            Set the control point to an entity's origin. Can specify whether to follow or not.
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetEntity(System.Int32,Sandbox.Entity,Vector3,System.Boolean)">
            <summary>
            Set the control point to an entity's origin offset by the local offset.
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetEntityAttachment(System.Int32,Sandbox.Entity,System.String,System.Boolean)">
            <summary>
            Set the control point to an entity's origin. Can specify whether to follow or not.
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetEntityBone(System.Int32,Sandbox.Entity,System.Int32,Transform,System.Boolean)">
            <summary>
            Set the control point to an entity's origin. Can specify whether to follow or not.
            </summary>
        </member>
        <member name="M:Sandbox.Sound.FromWorld(System.String,Vector3)">
            <summary>
            Create a sound originating from a world position
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Sound.FromEntity(System.String,Sandbox.Entity)">
            <summary>
            Create a sound originating from an entity
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Sound.FromScreen(System.String,System.Single,System.Single)">
            <summary>
            Create a sound originating from screen coordinates
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Sound.Stop">
            <summary>
            Stop the sound from playing
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Sound.SetVolume(System.Single)">
            <summary>
            Set the volume of the sound
            </summary>
            <param name="volume"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Sound.SetPitch(System.Single)">
            <summary>
            Set pitch value (Note: this is always executed and is multiplied with the initial random pitch)
            </summary>
        </member>
        <member name="M:Sandbox.Sound.SetRandomPitch(System.Single,System.Single)">
            <summary>
            Set random pitch value between min and max (Note: this is executed once)
            </summary>
        </member>
        <member name="M:Sandbox.Sound.SetPosition(Vector3)">
            <summary>
             Set the world position that this sounds originates from
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.EntityManager.CreateServerEntity(System.String)">
            <summary>
            The engine wants to create this entity by name.
            </summary>
        </member>
        <member name="P:Sandbox.AnimEntity.Sequence">
            <summary>
            The currently playing sequence/animation
            </summary>
        </member>
        <member name="P:Sandbox.AnimEntity.UseAnimGraph">
            <summary>
            Allows the entity to not use the anim graph so it can play sequences directly
            </summary>
        </member>
        <member name="M:Sandbox.AnimEntity.HasAnimGraph">
            <summary>
            Whether this entity's model has an anim graph or not
            </summary>
        </member>
        <member name="P:Sandbox.AnimEntity.PlaybackRate">
            <summary>
            Playback rate of the animations on this entity
            </summary>
        </member>
        <member name="P:Sandbox.AnimEntity.RootMotion">
            <summary>
            Experimental root motion velocity for anim graphs that use root motion
            </summary>
        </member>
        <member name="P:Sandbox.AnimEntity.RootMotionAngle">
            <summary>
            Experimental root motion angle velocity for anim graphs that use root motion
            </summary>
        </member>
        <member name="M:Sandbox.AnimEntity.SetAnimLookAt(System.String,Vector3)">
            <summary>
            Converts value to vector local to this entity's eyepos and passes it to SetAnimVector
            </summary>
        </member>
        <member name="F:Sandbox.Entity.IncomingClientInstance">
            <summary>
            Set in EntityManager when creating an entity from the network.
            If null we assume the entity was just a user initiated new() and
            will create a clientside entity
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsClientOnly">
            <summary>
            Returns true if this entity is a purely clientside entity, with no serverside components
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsDormant">
            <summary>
            Returns true if this entity is dormant (the client cannot see it, it isn't being networked)
            </summary>
        </member>
        <member name="M:Sandbox.Entity.InternalOnSetDormant(System.Boolean)">
            <summary>
            The entity has entered/exited PVS and has stopped being networked
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnNetworkDormant">
            <summary>
            The entity has left the client's visibility and has stopped receiving network updates.
            When it becomes active again OnNetworkActive will be called. 
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnNetworkActive">
            <summary>
            Entity has re-entered the client's visibility and has started receiving network updates again.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnActive">
            <summary>
            Entity is active (clientside). This is called after spawn.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsAuthority">
            <summary>
            Returns true if we have authority over this entity
            </summary>
        </member>
        <member name="P:Sandbox.Entity.NativeEntityClass">
            <summary>
            The name of the entity to create in the entity to base this
            entity off.
            </summary>
        </member>
        <member name="F:Sandbox.Entity.Task">
            <summary>
            Allows Task.Delay calls etc that are automatically cancelled when the entity is destroyed
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsWorld">
            <summary>
            Returns true if this entity is the world
            </summary>
        </member>
        <member name="P:Sandbox.Entity.LocalPosition">
            <summary>
            The entity's position relative to its parent (or the world if no parent)
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Position">
            <summary>
            The entity's position relative to its parent (or the world if no parent)
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Rotation">
            <summary>
            The entity's world rotation
            </summary>
        </member>
        <member name="P:Sandbox.Entity.WorldAng">
            <summary>
            The entity's angle
            </summary>
        </member>
        <member name="P:Sandbox.Entity.LocalRotation">
            <summary>
            The entity's local rotation
            </summary>
        </member>
        <member name="P:Sandbox.Entity.LocalScale">
            <summary>
            The entity's local scale
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Scale">
            <summary>
            The scale of the entity. 1 is normal.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Velocity">
            <summary>
            The velocity in world coords.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.AngularVelocity">
            <summary>
            The angular velocity in local coords
            </summary>
        </member>
        <member name="P:Sandbox.Entity.LocalVelocity">
            <summary>
            Velocity in local coords
            </summary>
        </member>
        <member name="P:Sandbox.Entity.BaseVelocity">
            <summary>
            Generally describes the velocity of this object that is caused by its parent moving.
            Examples would be conveyor belts and elevators.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.GroundEntity">
            <summary>
            Generally describes the velocity of this object that is caused by its parent moving.
            Examples would be conveyor belts and elevators.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EngineEntityName">
            <summary>
            The internal class name of this entity. For debug purposes only.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnHotloaded">
            <summary>
            Called when we hotload
            </summary>
        </member>
        <member name="M:Sandbox.Entity.GetEntityIntPtr">
            <summary>
            Careful and know what you're doing! This returns the raw pointer
            for the C_BaseEntity or the CBaseEntity - depending on what realm we're in
            </summary>
        </member>
        <member name="M:Sandbox.Entity.Delete">
            <summary>
            Delete this entity. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.DeleteAsync(System.Single)">
            <summary>
             Delete the entity in seconds
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnKilled">
            <summary>
            Called when there's no health left
            </summary>
        </member>
        <member name="M:Sandbox.Entity.ResetInterpolation">
            <summary>
            Reset the interpolation. 
            You can use this so if you move an entity it doesn't lerp to the new position
            </summary>
        </member>
        <member name="M:Sandbox.Entity.SetSimulationTime(System.Single)">
            <summary>
            I don't think we need to give people access to this?
            </summary>
        </member>
        <member name="M:Sandbox.Entity.Simulate(Sandbox.Client)">
            <summary>
            Called when simulating as part of a player's tick. Like if it's a pawn.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.FrameSimulate(Sandbox.Client)">
            <summary>
            Called each frame clientside only on Pawn (and anything the pawn decides to call it on)
            </summary>
        </member>
        <member name="M:Sandbox.Entity.BuildInput(Sandbox.InputBuilder)">
            <summary>
            Pawns get a chance to mess with the input clientside
            </summary>
        </member>
        <member name="M:Sandbox.Entity.GetClientOwner">
            <summary>
            Get the client owner. This will ascend up the owner chain to find the actual owner.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsLocalPawn">
            <summary>
            Will return true if we're clientside, this entity has an owner and we're
            currently treating this owner as the local client. This means the player 
            could be being spectated.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.RenderDirty">
            <summary>
            Mark render dirty
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PostCameraSetup(Sandbox.CameraSetup@)">
            <summary>
            Allow a pawn to set up the camera
            </summary>
        </member>
        <member name="M:Sandbox.Entity.CanCarry(Sandbox.Entity)">
            <summary>
            Return false if this entity objects to being picked up by this entity
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnCarryStart(Sandbox.Entity)">
            <summary>
            Allow the entity to do what it wants when it's added to the inventory.
            Default behaviour is to add the target entity as a parent and stop moving.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnCarryDrop(Sandbox.Entity)">
            <summary>
            Allow the entity to do what it wants when it's removed from the inventory
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnClientActive">
            <summary>
            Called when a player becomes active
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableDrawing">
            <summary>
            Turning this off will compleletely prevent the entity from drawing
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableShadowCasting">
            <summary>
            Don't cast no shadow
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableShadowReceive">
            <summary>
            Don't receive no shadow [TODO: DOESNT WORK]
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableShadowOnly">
            <summary>
            Render Only Shadows
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableShadowInFirstPerson">
            <summary>
            Render Shadows when hidden due to being in first person
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableHideInFirstPerson">
            <summary>
            Hide this model when in first person, or our parent is in first person
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableViewmodelRendering">
            <summary>
            Enable Viewmodel Rendering
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableDrawOverWorld">
            <summary>
            similar to ignorez to draw over world but still having depth info
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsFirstPersonMode">
            <summary>
            If this entity is being viewed through, or is a child of an entity that is being view
            through - will return true. This can be read are we in first person mode.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.InternalEntityKeyValue(System.UInt32,System.String,System.Int32)">
            <summary>
            Called befre InternalSpawn for every EntityKeyValue provided - usually provided by Hammer.
            For a property to be settable from Hammer, mark it with [HammerProp]
            You can then use it to do any configuration in Spawn.
            This is serverside only! Probably!
            If the conversion to the type you want to convert to isn't supported - talk to Garry
            </summary>
        </member>
        <member name="M:Sandbox.Entity.InternalEntityConnection(System.String,NativeEngine.EntityIOTargetType,System.String,System.String,System.String,System.Single,System.Int32)">
            <summary>
            Called on entity spawn with all the Hammer set IO connections
            </summary>
        </member>
        <member name="M:Sandbox.Entity.FireOutput(System.String,Sandbox.Entity,System.Object,System.Single)">
            <summary>
            Try to fire this output
            </summary>
        </member>
        <member name="M:Sandbox.Entity.Output.#ctor(Sandbox.Entity,System.String)">
            <summary>
            You shouldn't really ever be initializing this manually, 
            codegen will take care of that by generating a CreateHammerOutputs method for
            each entity filled with constructors for these.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Root">
            <summary>
            Gets the top most parent entity. If we don't have a parent, it might be us.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Owner">
            <summary>
            The entity that owns this entity
            </summary>
        </member>
        <member name="M:Sandbox.Entity.SetParent(Sandbox.Entity,System.String,System.Nullable{Transform})">
            <summary>
            Become a child of this entity and follow this attachment or bone if provided.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.SetParent(Sandbox.Entity,System.Int32,System.Nullable{Transform})">
            <summary>
            Finds the bone name and calls the other SetParent with it.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.SetParent(Sandbox.Entity,System.Boolean)">
            <summary>
            Set the parent to the passed entity
            </summary>
            <param name="entity"></param>
            <param name="boneMerge"></param>
        </member>
        <member name="M:Sandbox.Entity.IsActiveChild">
            <summary>
            Returns true if this is its parent's active child
            </summary>
        </member>
        <member name="M:Sandbox.Entity.ReBuildNetworkTables(Sandbox.Internal.INetwork)">
            <summary>
            Overriding the network class method so we can call FinalizeForEntity
            </summary>
        </member>
        <member name="P:Sandbox.Entity.NetworkIdent">
            <summary>
            Returns the entity's network id. Client only entities have a network id too!
            </summary>
        </member>
        <member name="P:Sandbox.Entity.PhysicsGroup">
            <summary>
            If this entity has multiple physics objects, a physics group lets you control them all as one.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.Touch(Sandbox.Entity)">
            <summary>
            An entity has touched this entity
            </summary>
        </member>
        <member name="M:Sandbox.Entity.StartTouch(Sandbox.Entity)">
            <summary>
            An entity has started touching this entity
            </summary>
        </member>
        <member name="M:Sandbox.Entity.EndTouch(Sandbox.Entity)">
            <summary>
            An entity has stopped touching this entity
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PhysicsClear">
            <summary>
            Destroy any physics objects
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PredictionDataStore.StompValue(System.String,System.Object)">
            <summary>
            A prediction error has occurred, so we're forcing the values to match what came from the server
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PredictionStore(System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Store our current predicted data in this slot
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PredictionRestore(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Restore our current predicted data from this slot
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PredictionVerify(System.Int32,System.Int32)">
            <summary>
            We just got predicted data from the server for this command_num. 
            The server data is in slot -1
            Our stored data is in the passed slot
            They should be pretty much identical. Lets compare them and check.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnPredictionError(System.String,System.Object)">
            <summary>
            On prediction errors right now we're just stomping the value in the current 
            storage and any future. This could lead to a situation where the client is in
            front by a number of ticks and the value changes, it keeps flipping back.
            This should really trigger a re-simulate in the engine code. TODO.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PredictionDestroy">
            <summary>
            Prediction ended, clean up
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PredictionShift(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PlayerSetupVisibility(System.Int32,System.IntPtr)">
            <summary>
            Called by the server to determine what the player should see
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Tags">
            <summary>
            Accessor to add, remove and check entity tags
            </summary>
        </member>
        <member name="F:Sandbox.Entity.networkTags">
            <summary>
            Tags that exist on the server and are networked down to the client
            </summary>
        </member>
        <member name="M:Sandbox.Entity.UpdateTagsFromNetwork">
            <summary>
            This is called on the client after a network update to keey the networkTags list up to date
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnTagAdded(System.String)">
            <summary>
            Called when a tag was added to this entity. On the client this will get called
            when an entity is created or enters PVS.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnTagRemoved(System.String)">
            <summary>
            Called when a tag was removed from this entity.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.EntityTags">
            <summary>
            Entity Tags are strings you can set and check for on any entity. Internally
            these strings are tokenized and networked so they're also available clientside.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityTags.Has(System.String)">
            <summary>
            Returns true if we have this tag
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityTags.Set(System.String,System.Boolean)">
            <summary>
            Set the tag on this entity
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityTags.Add(System.String)">
            <summary>
            Try to add the tag to this entity. 
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityTags.Add(System.String[])">
            <summary>
            Adds multiple tags. Calls Add for each tag.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityTags.Remove(System.String)">
            <summary>
            Try to remove the tag from this entity
            </summary>
        </member>
        <member name="M:Sandbox.Internal.SpawnFlagAccessor.Has``1(``0)">
            <summary>
            Return true if entity has this spawngflag
            </summary>
        </member>
        <member name="F:Sandbox.Internal.Lobby.OnPartyAcceptInvite">
            <summary>
            Party invite was accepted using the Steam Overlay
            </summary>
        </member>
        <member name="F:Sandbox.Internal.Lobby.OnPartyInvite">
            <summary>
            Party invite has been created
            </summary>
        </member>
        <member name="M:Sandbox.Internal.MenuTools.PackageQuery(Sandbox.Package.Type,System.String,System.String)">
            <summary>
            Find package information
            </summary>
        </member>
        <member name="T:Sandbox.Internal.NetworkAtomic`1">
            <summary>
            A fixed size Play Old Data variable. Can be a built in type or a struct.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.NetworkString`1">
            <summary>
            A standard string
            </summary>
        </member>
        <member name="P:Sandbox.Internal.INetwork.IsLocal">
            <summary>
            True if we're on the "send only to local player" group
            </summary>
        </member>
        <member name="M:Sandbox.Internal.NetworkTableBuilder.FinalizeEmbedded(Sandbox.NetworkComponent,Sandbox.Internal.INetwork)">
            <summary>
            Finalize for embedded, which can only have atomics
            </summary>
        </member>
        <member name="M:Sandbox.Internal.NetworkTableBuilder.FinalizeForEntity(Sandbox.Entity)">
            <summary>
            Finalize for entity, which can have tables
            </summary>
        </member>
        <member name="T:Sandbox.Internal.EventSystem.EventClass">
            <summary>
            A Type with events on it
            </summary>
        </member>
        <member name="T:Sandbox.Internal.EventSystem.EventAction">
            <summary>
            A method on a type
            </summary>
        </member>
        <member name="T:Sandbox.Internal.EventSystem.EventList">
            <summary>
            A list of events, usually indexed by the event name
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EventSystem.RegisterAssembly(System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            Register an assembly. If old assembly is valid, we try to remove all of the old event hooks
            from this assembly, while retaining a list of objects.
            </summary>
        </member>
        <member name="T:Sandbox.EntityEffects">
            <summary>
            Note - most of these aren't used
            </summary>
        </member>
        <member name="F:Sandbox.EntityEffects.HiddenInFirstPerson">
            <summary>
            Copy the parent's nodraw..
            </summary>
        </member>
        <member name="F:Sandbox.EntityEffects.DrawAsViewModel">
            <summary>
            Change the render layer to viewmodel
            </summary>
        </member>
        <member name="F:Sandbox.EntityEffects.DrawOverDepth">
            <summary>
            similar to ignorez to draw over world but still having depth info
            </summary>
        </member>
        <member name="M:Sandbox.EntityIO.Output.BuildTargets(Sandbox.Entity)">
            <summary>
            Get a list of entities that are appropriate targets for this
            </summary>
        </member>
        <member name="M:Sandbox.EntityIO.Output.ShouldSendToEntity(Sandbox.Entity)">
            <summary>
            TODO - TargetType
            </summary>
        </member>
        <member name="T:Sandbox.IUse">
            <summary>
            If an entity implements this it'll be usable by looking at it and pressing the USE button.
            </summary>
        </member>
        <member name="M:Sandbox.IUse.OnUse(Sandbox.Entity)">
            <summary>
            The (probably) player has used this entity. Return true if the player
            should continually use it. Return false when the player should stop using it.
            For example - a health charger will return true while the player is taking health.
            We're passing the player in as an entity so at some point
            if we want NPCs using shit, we can do that without the assumption.
            </summary>
        </member>
        <member name="M:Sandbox.IUse.IsUsable(Sandbox.Entity)">
            <summary>
            Should return true if the entity can use this entity.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetBodyGroup(System.Int32,System.Int32)">
            <summary>
            Set body group to replace parts of the model
            Uses index for bodygroup
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetBodyGroup(System.String,System.Int32)">
            <summary>
            Set body group to replace parts of the model
            Uses name for bodygroup
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.CopyBodyGroups(Sandbox.ModelEntity)">
            <summary>
            Copy body groups over to this model
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.EnableAllCollisions">
            <summary>
            Enable or disable all physics/solid collisions as well as 
            trace collisions.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.EnableTouch">
            <summary>
            Allow Touch callbacks to be called
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.EnableTouchPersists">
            <summary>
            Allow Touch callbacks to be called
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.EnableHitboxes">
            <summary>
            Use Hitboxes for traces etc
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.EnableSelfCollisions">
            <summary>
            Allow ragdoll parts to collide with each other
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.SurroundingBoundsMode">
            <summary>
            Set the method used to work out the surrounding bounds. The bounds are important for 
            traces and collision checks, because they're used the quickly eliminate collisions.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetInteractsAs(Sandbox.CollisionLayer)">
            <summary>
            Which interaction layers do I represent?
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetInteractsWith(Sandbox.CollisionLayer)">
            <summary>
            Which interaction layers do I interact or collide with?
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetInteractsExclude(Sandbox.CollisionLayer)">
            <summary>
            Which interaction layers do I represent?
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.InternalOnNewModel">
            <summary>
            Called from engine when a new model is set
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.OnNewModel(Sandbox.Model)">
            <summary>
            Called when the model is changed.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.TakeDecalsFrom(Sandbox.ModelEntity)">
            <summary>
            Move all of the decals from this entity onto ourself
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.OnCarryStart(Sandbox.Entity)">
            <summary>
            Allow the entity to do what it wants when it's added to the inventory.
            Default behaviour is to add the target entity as a parent and stop moving.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.OnCarryDrop(Sandbox.Entity)">
            <summary>
            Allow the entity to do what it wants when it's removed from the inventory
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.GlowColor">
            <summary>
            Get and set the color of the glow override on this object.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.GlowState">
            <summary>
            Get and set the behaviour of the glow.
            Note that you still need to use GlowActive to enable it.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.GlowActive">
            <summary>
            Gets or set if the glow is active on the object.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.GlowDistanceStart">
            <summary>
            The minimum distance that this object will start glowing.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.GlowDistanceEnd">
            <summary>
            The maximum distance that this object will glow.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.MaterialGroupCount">
            <summary>
            Set material group to replace materials of the model
            Uses index for material group
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetMaterialGroup(System.Int32)">
            <summary>
            Set material group to replace materials of the model
            Uses index for material group
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.CopyMaterialGroup(Sandbox.ModelEntity)">
            <summary>
            Copy material group over to this model
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.MoveTo(Rotation,System.Single)">
            <summary>
            AGH! This doesn't work! Either the Rotation.Difference or .Angles() is fucked!
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.MoveTo(Angles,System.Single)">
            <summary>
            Angles. Blah.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.MoveFinished">
            <summary>
            Called when your move is finished
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.MoveBlocked(Sandbox.Entity)">
            <summary>
            Called when your move is blocked
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.PhysicsEnabled">
            <summary>
            Enable or disable physics motion
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.GetBonePhysicsBody(System.Int32)">
            <summary>
            Get the physics body attached to this bone
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.GetBone(Sandbox.PhysicsBody)">
            <summary>
            Get the bone that this physics body is attached to
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.PhysicsClear">
            <summary>
            Destroy any physics objects
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.GetHitboxBone(System.Int32)">
            <summary>
            Return which bone is this hitbox attached to
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.GetHitboxGroup(System.Int32)">
            <summary>
            Return group id for this hitbox
            </summary>
        </member>
        <member name="F:Sandbox.GlowStates.GlowStateOff">
            <summary>Doesn't show any glow.</summary>
        </member>
        <member name="F:Sandbox.GlowStates.GlowStateUse">
            <summary>Glow appears when object is useable.</summary>
        </member>
        <member name="F:Sandbox.GlowStates.GlowStateLookAt">
            <summary>Glow appears when you look at object.</summary>
        </member>
        <member name="F:Sandbox.GlowStates.GlowStateOn">
            <summary>Glow is always enabled when active.</summary>
        </member>
        <member name="F:Sandbox.MoveType.Physics">
            <summary>
            Use physics simulation
            </summary>
        </member>
        <member name="F:Sandbox.MoveType.Push">
            <summary>
            no clip to world, push and crush
            </summary>
        </member>
        <member name="T:Sandbox.Networked">
            <summary>
            A network capable object
            </summary>
        </member>
        <member name="P:Sandbox.Networked.NetworkIdent">
            <summary>
            Should return the ID of this entity that is common across the network
            </summary>
        </member>
        <member name="M:Sandbox.Networked.RpcWriteIdent(Sandbox.NetWrite)">
            <summary>
            Writes the RpcClient identity to a network message. This works
            by calling the parent functions first so that they'll be read back
            in the right order.
            </summary>
        </member>
        <member name="M:Sandbox.Networked.OnCallRemoteProcedure(System.Int32,Sandbox.NetRead)">
            <summary>
             Generated at compile-time: calls remote procedure implementations
            </summary>
        </member>
        <member name="M:Sandbox.Networked.ReceiveMessageFromServer(Sandbox.NetRead)">
            <summary>
            Called from engine clientside when an entity message has been recieved
            </summary>
        </member>
        <member name="M:Sandbox.Networked.RecieveMessageFromClient(System.IntPtr,System.Int32)">
            <summary>
            Called from engine clientside when an entity message has been recieved
            </summary>
        </member>
        <member name="P:Sandbox.ClientEntity.IsLocalPlayer">
            <summary>
            Returns true if this is the local player. This will
            only return true on the client for the player that is
            being controlled. It won't ever return true serverside.
            </summary>
        </member>
        <member name="P:Sandbox.ClientEntity.SteamId">
            <summary>
            This player's SteamId
            </summary>
        </member>
        <member name="M:Sandbox.ClientEntity.SendCommandToClient(System.String)">
            <summary>
            Send a console command to this client to be run. Use ConsoleSystem.Build to safely build
            a console command.
            </summary>
        </member>
        <member name="M:Sandbox.ClientEntity.SetScore(System.String,System.Object)">
            <summary>
            Updates a player info value serverside, which is available via the PlayerInfo system clientside
            </summary>
        </member>
        <member name="M:Sandbox.ClientEntity.PlayerSetupVisibility(System.Int32,System.IntPtr)">
            <summary>
            Called by the server to determine what the player can see, from a network pov
            Add points here that the player should see.
            </summary>
        </member>
        <member name="P:Sandbox.ClientEntity.Pvs">
            <summary>
            Potentially Visible Set. Use this to add new areas to the player's PVS. This is useful if you're
            spectating another entity and want to be able to see what they see etc.
            </summary>
        </member>
        <member name="M:Sandbox.PvsConfig.Add(Sandbox.Entity)">
            <summary>
            Add an entity tp the player's PVS. The player will be able to see everything that this entity can see.
            </summary>
        </member>
        <member name="M:Sandbox.PvsConfig.Remove(Sandbox.Entity)">
            <summary>
            Remove entity from this player's PVS
            </summary>
        </member>
        <member name="M:Sandbox.PvsConfig.Clear">
            <summary>
            Remove all specialization
            </summary>
        </member>
        <member name="M:Sandbox.PvsConfig.Clean">
            <summary>
            Remove all entries that aren't value
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetKeyWithBinding(System.String)">
            <summary>
            Returns the name of a key that is bound to this value
            </summary>
        </member>
        <member name="P:Sandbox.Input.Forward">
            <summary>
            A float in range of -1 to 0 to 1 that represents how much the user wants to move forwards (1) or backwards (-1)
            </summary>
        </member>
        <member name="P:Sandbox.Input.Left">
            <summary>
            A float in range of -1 to 0 to 1 that represents how much the user wants to move left (1) or right (-1)
            </summary>
        </member>
        <member name="P:Sandbox.Input.Up">
            <summary>
            A float in range of -1 to 0 to 1 that represents how much the user wants to move up (1) or down (-1)
            </summary>
        </member>
        <member name="P:Sandbox.Input.Position">
            <summary>
            The location of the camera on the client when this command was issued
            </summary>
        </member>
        <member name="M:Sandbox.Input.Down(Sandbox.InputButton)">
            <summary>
            Button is pressed down
            </summary>
        </member>
        <member name="M:Sandbox.Input.Pressed(Sandbox.InputButton)">
            <summary>
            Button wasn't pressed but now is it
            </summary>
        </member>
        <member name="M:Sandbox.Input.Released(Sandbox.InputButton)">
            <summary>
            Button was pressed but now it isn't
            </summary>
        </member>
        <member name="M:Sandbox.Input.UpdateFrom(Sandbox.Client,NativeEngine.CUserCmd)">
            <summary>
            Called every tick
            </summary>
        </member>
        <member name="M:Sandbox.Input.UpdateFrom(Sandbox.Client,NativeEngine.InputData)">
            <summary>
            Called each frame, in between ticks
            </summary>
        </member>
        <member name="M:Sandbox.Input.Clear">
            <summary>
            Todo clear the lot
            </summary>
        </member>
        <member name="M:Sandbox.RenderEntity.UpdateSceneObject(Sandbox.SceneObject)">
            <summary>
            Keep the scene object updated. By default this moves the transform to match this entity's transform
            and updates the bounds to the new position.
            </summary>
        </member>
        <member name="M:Sandbox.RenderEntity.DoRender(Sandbox.SceneObject)">
            <summary>
            Render this entity. Here's some warnings:
            1. This is called in a thread. Don't create/delete/move entities in this loop
            2. This can be called multiple times per frame for different scene layers. For example, once to
            	draw the shadow caster, once to draw the opaque object, once to draw the transparent object. 
            	Obviously which of these get called depends on your object setup. Check Render.Layer to 
            	determine which layer is being rendered.
            </summary>
        </member>
        <member name="T:Sandbox.FileSystem">
            <summary>
            A filesystem that can be accessed by the game
            </summary>
        </member>
        <member name="M:Sandbox.GameBase.Shutdown">
            <summary>
            Called when the server is going away
            </summary>
        </member>
        <member name="M:Sandbox.GameBase.ClientJoined(Sandbox.Client)">
            <summary>
            Client has joined the server. Create their puppets.
            </summary>
        </member>
        <member name="M:Sandbox.GameBase.ClientDisconnect(Sandbox.Client,Sandbox.NetworkDisconnectionReason)">
            <summary>
            Client has disconnected from the server. Remove their entities etc.
            </summary>
        </member>
        <member name="M:Sandbox.GameBase.CanHearPlayerVoice(Sandbox.Client,Sandbox.Client)">
            <summary>
            Can we hear the player's voice. If not we won't send the data to this client.
            </summary>
        </member>
        <member name="M:Sandbox.GameBase.BuildCamera(Sandbox.CameraSetup)">
            <summary>
            Update the camera setup
            </summary>
        </member>
        <member name="M:Sandbox.GameBase.OnVoicePlayed(System.UInt64,System.Single)">
            <summary>
            Someone is speaking via voice chat. This might be someone in your game, 
            or in your party, or in your lobby.
            </summary>
        </member>
        <member name="M:Sandbox.GameLoop.PostCreateInterface">
            <summary>
            Called immediately after the interface has been set up
            </summary>
        </member>
        <member name="M:Sandbox.GameLoop.PreOnActivate">
            <summary>
            Server: Right before map entity spawn
            </summary>
        </member>
        <member name="M:Sandbox.GameLoop.PostOnActivate">
            <summary>
            Server: Right after map entity spawn
            </summary>
        </member>
        <member name="M:Sandbox.GameLoop.LoopShutdown">
            <summary>
            The last thing that is ever called. 
            This is right at the end after everything has been destroyed.
            </summary>
        </member>
        <member name="M:Sandbox.GameLoop.DoShutdown">
            <summary>
            Called to clear the state. Because of spagetti code this is probably called in 4 
            different places when disconnecting from a server.
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Attacker">
            <summary>
            The player or NPC or exploding barrel (etc)1 that is attacking
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Weapon">
            <summary>
            The weapon that the attacker is using
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Position">
            <summary>
            The position the damage is being inflicted (the bullet entry point)
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Force">
            <summary>
            The force of the damage - for moving physics etc. This would be the tradjectory
            of the bullet multiplied by the speed and mass.
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Damage">
            <summary>
            The actual amount of damage this attack causes
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Flags">
            <summary>
            Damage flags, extra infomation about this attack
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Body">
            <summary>
            The physics body that was hit
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.HitboxIndex">
            <summary>
            The hitbox index
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.BoneIndex">
            <summary>
            The bone index that the hitbox was attached to
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.FromBullet(Vector3,Vector3,System.Single)">
            <summary>
            Creates a new DamageInfo with the DamageFlag Bullet
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.Generic(System.Single)">
            <summary>
            Creates a new DamageInfo with the DamageFlag Generic
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.Explosion(Vector3,Vector3,System.Single)">
            <summary>
            Creates a new DamageInfo with the DamageFlag Blast
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithAttacker(Sandbox.Entity,Sandbox.Entity)">
            <summary>
            Set the attacker
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithWeapon(Sandbox.Entity)">
            <summary>
            Set the attacker
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithFlag(Sandbox.DamageFlags)">
            <summary>
            Add flag(s)
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithHitBody(Sandbox.PhysicsBody)">
            <summary>
            Sets the hit physics body
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithHitbox(System.Int32)">
            <summary>
            Sets the hitbox index
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithBone(System.Int32)">
            <summary>
            Sets the hitbox index
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithPosition(Vector3)">
            <summary>
            Sets the position
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithForce(Vector3)">
            <summary>
            Sets the force
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.UsingTraceResult(Sandbox.TraceResult)">
            <summary>
            Fills in the PhysicsBody and Hitbox from the trace result
            </summary>
        </member>
        <member name="F:Sandbox.LifeState.Alive">
            <summary>
            Alive as normal
            </summary>
        </member>
        <member name="F:Sandbox.LifeState.Dying">
            <summary>
            Playing a death animation
            </summary>
        </member>
        <member name="F:Sandbox.LifeState.Dead">
            <summary>
            Dead, lying still
            </summary>
        </member>
        <member name="F:Sandbox.LifeState.Respawnable">
            <summary>
            Can respawn, usually waiting for some client action to respawn
            </summary>
        </member>
        <member name="F:Sandbox.LifeState.Respawning">
            <summary>
            Is in the process of respawning
            </summary>
        </member>
        <member name="P:Sandbox.Global.InGame">
            <summary>
            Return true if we're in a game (ie, not in the main menu)
            </summary>
        </member>
        <member name="P:Sandbox.Global.IsClosing">
            <summary>
            Set to true when the game is closing
            </summary>
        </member>
        <member name="P:Sandbox.Global.TickRate">
            <summary>
            Amount of ticks to perform per second. Higher is smoother and more accurate but uses more
            power. Lower can be laggy and weird things can happen. Default is 60.
            </summary>
        </member>
        <member name="P:Sandbox.Global.TickInterval">
            <summary>
            1 / TickRate
            </summary>
        </member>
        <member name="P:Sandbox.Global.PhysicsSubSteps">
            <summary>
            If you're seeing objects go through other objects or you have a low tickrate, you might
            want to increase the number of physics substeps. This breaks physics steps down into this 
            many substeps. The default is 1 and works pretty good.
            Be aware that the number of physics ticks per second is going to be tickrate * substeps. So 
            if you're ticking at 90 and you have SubSteps set to 1000 then you're going to do 90,000 steps 
            per second. So be careful here.
            </summary>
        </member>
        <member name="P:Sandbox.Global.PhysicsTimeScale">
            <summary>
            How fast (or slow) the physics should run.
            </summary>
        </member>
        <member name="M:Sandbox.HotloadManager.DoSwap">
            <summary>
            Does the actual hotload
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.Down(Sandbox.InputButton)">
            <summary>
            Button is pressed down
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.Pressed(Sandbox.InputButton)">
            <summary>
            Button wasn't pressed but now is it
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.Released(Sandbox.InputButton)">
            <summary>
            Button was pressed but now it isn't
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.ClearButton(Sandbox.InputButton)">
            <summary>
            Remove this button, so it's no longer being pressed
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.SetButton(Sandbox.InputButton,System.Boolean)">
            <summary>
            Set button as pressed down
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.SuppressButton(Sandbox.InputButton)">
            <summary>
            Suppress a button, it won't show as down again until it's pressed again
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.Process(NativeEngine.InputData@)">
            <summary>
            Called multiple times between ticks
            </summary>
        </member>
        <member name="P:Sandbox.Light.Pos">
            <summary>
            Relative position of the light 
            </summary>
        </member>
        <member name="P:Sandbox.Light.WorldPos">
            <summary>
            World position of the light 
            </summary>
        </member>
        <member name="P:Sandbox.Light.Ang">
            <summary>
            World angles of the light
            </summary>
        </member>
        <member name="P:Sandbox.Light.WorldAng">
            <summary>
            World angles of the light
            </summary>
        </member>
        <member name="P:Sandbox.Light.LightColor">
            <summary>
            Color and brightness of the light
            </summary>
        </member>
        <member name="P:Sandbox.Light.Falloff">
            <summary>
            Attenuation of how much brightness the light loses the more it travels
            </summary>
        </member>
        <member name="P:Sandbox.Light.Radius">
            <summary>
            Radius of the light in units
            </summary>
        </member>
        <member name="P:Sandbox.SpotLight.SpotCone">
            <summary>
            Sets how much the spot light would spread, with inner and outer cone angles in degrees
            </summary>
        </member>
        <member name="M:Sandbox.SunLight.ConnectOrCreateThisNative">
            <summary>
            Fetch the current sunlight from the world if such exists, if not, create a new sunlight
            </summary>
        </member>
        <member name="M:Sandbox.NavMesh.GetClosestPoint(Vector3)">
            <summary>
            Returns the closest point on the navmesh. Or null if not found.
            </summary>
        </member>
        <member name="M:Sandbox.NavMesh.GetPointWithinRadius(Vector3,System.Single,System.Single)">
            <summary>
            Returns the closest point on the navmesh. Or null if not found.
            </summary>
        </member>
        <member name="T:Sandbox.DownloadedAssets">
            <summary>
            Client class for handling storing and access of downloaded files.
            </summary>
        </member>
        <member name="M:Sandbox.DownloadedAssets.AddFileAsync(System.String,System.String)">
            <summary>
            Copy the file from the cache folder to our memory based filesystem.
            We should probably just be redirecting filenames here.
            </summary>
        </member>
        <member name="M:Sandbox.DownloadedAssets.GetCacheName(System.String,System.UInt32)">
            <summary>
            Get the cache filename we should use for this downloaded file
            </summary>
        </member>
        <member name="M:Sandbox.FileSend.Queue(System.Int32)">
            <summary>
            Add a file to download
            </summary>
        </member>
        <member name="T:Sandbox.NetworkAssetList">
            <summary>
            Creates and maintains a list of available assets that the client can download
            Along with their CRCs - which we can use to assure we're using the same shit
            </summary>
        </member>
        <member name="M:Sandbox.NetworkAssetList.Initialize">
            <summary>
            Populates with all files
            </summary>
        </member>
        <member name="M:Sandbox.NetworkAssetList.IgnoredFile(System.String)">
            <summary>
            Opportunity to filter out files we don't want to send to the client
            </summary>
        </member>
        <member name="P:Sandbox.ServerInfo.MountedAddons">
            <summary>
            Addons that the user should have installed and mounted
            </summary>
        </member>
        <member name="P:Sandbox.NetRead.Remaining">
            <summary>
            The amount of data (in bytes) remaining to be read
            </summary>
        </member>
        <member name="M:Sandbox.NetRead.IsSupported(System.Type)">
            <summary>
            Get whether or not a type can be read by NetRead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.NetRead.IsSupported``1(System.Span{``0})">
            <summary>
            Get whether or not a value can be read by NetRead. This is a little
            trick because `GetType()` does not work with Span.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.NetRead.IsSupported(System.Object)">
            <summary>
            Get whether or not a value can be read by NetRead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.NetRead.ReadUnmanagedArray``1(``0[])">
            <summary>
            A dedicated method for arrays of unmanaged types that is faster to allow processing
            of large arrays
            </summary>
        </member>
        <member name="T:Sandbox.NetworkClient">
            <summary>
            A Clientside Client->Server connection. This exists before the player
            or anything else and exists for the duration of the connection to the server.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkClient.DownloadContent">
            <summary>
            Called during connection. The client looks at the Assets table and decides whether they should
            download any files.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkClient.Ready">
            <summary>
            If true then we've completed sign on and are in the game
            </summary>
        </member>
        <member name="M:Sandbox.NetworkClient.Shutdown">
            <summary>
            Called on disconnect
            </summary>
        </member>
        <member name="M:Sandbox.NetworkClient.Send``1(Sandbox.NetMsgType,``0)">
            <summary>
            Send this value to the server
            </summary>
        </member>
        <member name="M:Sandbox.NetworkClient.Send(Sandbox.NetMsgType,System.Void*,System.Int32)">
            <summary>
            Send a message of this type to the server
            </summary>
        </member>
        <member name="M:Sandbox.NetworkClient.SendJson``1(Sandbox.NetMsgType,``0)">
            <summary>
            Send a JSON message to the server
            </summary>
        </member>
        <member name="M:Sandbox.NetworkClient.OnNet(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Called when receiving a message from the server
            </summary>
        </member>
        <member name="M:Sandbox.NetworkClient.ProcessServerInfo(System.String,System.String)">
            <summary>
            The server has sent information about itself. Return false if we shouldn't connect.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkClient.RequestAnyFiles">
            <summary>
            Called during connection. The client looks at the Assets table and decides whether they should
            download any files.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkClient.OnFileChanged(System.Int32)">
            <summary>
            Called when a value changes in the Assets string table. This means
            that the CRC of a file has changed or been added. 
            </summary>
        </member>
        <member name="M:Sandbox.NetworkClient.ShouldRequestFile(System.Int32)">
            <summary>
            Checks for the existing file and returns a positive value if 
            we should request this file.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkClient.NetMsg_FileStart(System.Span{System.Byte})">
            <summary>
            Server has started sending a file from the server.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkClient.NetMsg_FileChunk(System.Span{System.Byte})">
            <summary>
            Got a file chunk from the server
            </summary>
        </member>
        <member name="M:Sandbox.Networking.OnNetMessage(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            The entrance point from the engine when a managed network message is recvd
            </summary>
        </member>
        <member name="M:Sandbox.NetworkServer.SendPlayerVoiceMessage(Sandbox.Client,Sandbox.Client,System.Span{System.Byte})">
            <summary>
            Send player voice to another player
            </summary>
        </member>
        <member name="M:Sandbox.NetWrite.WriteUnmanagedArray``1(``0[])">
            <summary>
            A dedicated method for writing an array of unmanaged types
            </summary>
        </member>
        <member name="M:Sandbox.Prediction.Tick">
            <summary>
            At this point if we're scoping right, prediction should always be enabled.
            If it isn't then someone fucked up - lets not let that problem persist forever.
            </summary>
        </member>
        <member name="T:Sandbox.To">
            <summary>
            A wrapper to define which clients to send network things to. This
            aims to make code more readable by having the target argument in generated
            functions be more obvious and visible.
            </summary>
        </member>
        <member name="M:Sandbox.To.Single(Sandbox.Entity)">
            <summary>
            Send to a single client (the client owner of this pawn)
            </summary>
        </member>
        <member name="M:Sandbox.To.Single(Sandbox.Client)">
            <summary>
            Send to a single client
            </summary>
        </member>
        <member name="M:Sandbox.To.Multiple(System.Collections.Generic.IEnumerable{Sandbox.Client})">
            <summary>
            Send to multiple clients
            </summary>
        </member>
        <member name="P:Sandbox.To.Everyone">
            <summary>
            The same as To.Multiple( Client.All )
            </summary>
        </member>
        <member name="M:Sandbox.PlayerScore.PlayerJoined(Sandbox.Client)">
            <summary>
            A player has joined, set up their info slot
            </summary>
        </member>
        <member name="M:Sandbox.PlayerScore.PlayerDisconnected(Sandbox.Client)">
            <summary>
            When a player disconnects, crush their slot
            </summary>
        </member>
        <member name="M:Sandbox.PlayerScore.TakeSlot">
            <summary>
            Recycle an old slot, or create a new one
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.PlayerScore.OnStringAddedOrChanged(System.Int32)">
            <summary>
            Player info has changed
            </summary>
        </member>
        <member name="M:Sandbox.PlayerScore.ServerTick">
            <summary>
            Update the slots that need updating
            </summary>
        </member>
        <member name="M:Sandbox.Precache.Add(System.String)">
            <summary>
            Add a resource that the client should load. This is called 
            automatically when doing things such as setting a model and for
            the most part you should never have to call this.
            </summary>
        </member>
        <member name="M:Sandbox.Precache.OnStringAddedOrChanged(System.Int32)">
            <summary>
            Player info has changed
            </summary>
        </member>
        <member name="M:Sandbox.StringPool.OnStringAddedOrChanged(System.Int32)">
            <summary>
            String table changed
            </summary>
        </member>
        <member name="M:Sandbox.StringTables.Init">
            <summary>
            On server this gets called once
            On client this can get called multiple times
            </summary>
        </member>
        <member name="P:Sandbox.StringTable.Name">
            <summary>
            The name of this string table
            </summary>
        </member>
        <member name="M:Sandbox.StringTable.Count">
            <summary>
            Returns the number of strings in this table
            </summary>
        </member>
        <member name="F:Sandbox.StringTable.OnStringAddedOrChanged">
            <summary>
            Called clientside when a string is added or changed
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Always">
            <summary>
            This will *ALWAYS* collide
            This group does not generate contacts or interact with any other groups by default
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Never">
            <summary>
            Never collide with anything
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Trigger">
            <summary>
            Trigger layer, never collides with anything, only triggers/interacts
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.ConditionallySolid">
            <summary>
            Conditionally solid means that the collision response will be zero or as defined in the table when there are matching interactions
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Default">
            <summary>
            standard dynamic rigid object, finite mass
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Debris">
            <summary>
            Collides with nothing but world and static stuff
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.DebrisInteractive">
            <summary>
            Collides with everything except other interactive debris or debris
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Interactive">
            <summary>
            Collides with everything except interactive debris or debris
            </summary>
        </member>
        <member name="F:Sandbox.CollisionLayer.Player">
            <summary>
            Player hull (movement and trace attacks)
            </summary>
        </member>
        <member name="F:Sandbox.CollisionLayer.Debris">
            <summary>
            Ragdolls etc
            </summary>
        </member>
        <member name="M:Sandbox.Joints.ConicalJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="M:Sandbox.Joints.GenericJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="M:Sandbox.Joints.PrismaticJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="M:Sandbox.Joints.RevoluteJointBuilder.WithLimitEnabled(System.Single,System.Single)">
            <summary>
            Enables hinge limit
            </summary>
            <param name="minAngle">Minimum hinge angle in degrees</param>
            <param name="maxAngle">Maximum hinge angle in degrees</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Joints.RevoluteJointBuilder.WithAngleMotor(System.Single,System.Single,System.Single)">
            <summary>
            Enables motor with angle target (Use angular spring to 'pull' towards target angle)
            </summary>
            <param name="targetAngle">Angular motor target angle</param>
            <param name="frequency">Angular motor frequency</param>
            <param name="dampingRatio">Angular motor damping ratio</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Joints.RevoluteJointBuilder.WithVelocityMotor(System.Single,System.Single)">
            <summary>
            Enables motor with velocity target (Use torque to reach desired relative velocity)
            </summary>
            <param name="targetVelocity">Angular motor target velocity</param>
            <param name="maxTorque">Angular motor maximum torque to reach target velocity</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Joints.RevoluteJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="M:Sandbox.Joints.SphericalJointBuilder.WithAngleMotor(Rotation,System.Single,System.Single)">
            <summary>
            Enables motor with angle target (Use angular spring to 'pull' towards target angle)
            </summary>
            <param name="targetRot">Angular motor target orientation</param>
            <param name="frequency">Angular motor frequency</param>
            <param name="dampingRatio">Angular motor damping ratio</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Joints.SphericalJointBuilder.WithVelocityMotor(System.Single,System.Single)">
            <summary>
            Enables motor with velocity target (Use torque to reach desired relative velocity)
            </summary>
            <param name="targetVelocity">Angular motor target velocity</param>
            <param name="maxTorque">Angular motor maximum torque to reach target velocity</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Joints.SphericalJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="M:Sandbox.Joints.SpringJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="M:Sandbox.Joints.WeldJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Conical">
            <summary>
            Start creation of Conical joint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Generic">
            <summary>
            Start creation of Generic joint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Prismatic">
            <summary>
            Start creation of Prismatic joint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Revolute">
            <summary>
            Start creation of Revolute joint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Spherical">
            <summary>
            Start creation of Spherical joint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Spring">
            <summary>
            Start creation of Spring joint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Weld">
            <summary>
            Start creation of Weld joint
            </summary>
        </member>
        <member name="M:Sandbox.Physics.GetPointContents(Vector3,System.Boolean)">
            <summary>
            Get what's at this point
            </summary>
        </member>
        <member name="M:Sandbox.Physics.TestPointContents(Vector3,Sandbox.CollisionLayer,System.Boolean)">
            <summary>
            Is this at this point
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.EnableTouch">
            <summary>
            Allow Touch callbacks to be called
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.Wake">
            <summary>
            Wake up this physics body. Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.Sleep">
            <summary>
            Put this physics body to sleep. Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.IsSleeping">
            <summary>
            Returns the current sleep state of this physics body. Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsGroup">
            <summary>
            Represets a set of PhysicsBody objects
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.Wake">
            <summary>
            Wake all physics bodies of this physics group. Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.Sleep">
            <summary>
            Put all physics bodies of this physics group to sleep. Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.SetSurface(System.String)">
            <summary>
            Sets the physical properties of all physics bodies of this group.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Sandbox.Material.CreateCopy">
            <summary>
            Create a copy of this material
            </summary>
        </member>
        <member name="M:Sandbox.Material.OverrideTexture(System.String,Sandbox.Texture)">
            <summary>
            Override texture parameter (Color, Normal, etc)
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetBounds(Vector3,Vector3)">
            <summary>
            Set the render bounds of this mesh, default is infinite
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexRange(System.Int32,System.Int32)">
            <summary>
            Set how many vertices this mesh draws (if there's no index buffer)
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexRange(System.Int32,System.Int32)">
            <summary>
            Set how many indices this mesh draws
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateIndexBuffer(System.Int32,System.Span{System.Int32})">
            <summary>
            Create a index buffer with a number of indices
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexBufferData(System.Span{System.Int32},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(System.Int32,Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(System.Int32,System.Int32,Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(System.Int32,Sandbox.VertexAttribute[],System.Span{``0})">
            <summary>
            Create a vertex buffer with a number of vertices, an array of vertex attributes can be passed in
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexBufferData``1(System.Span{``0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(System.Int32,Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(System.Int32,System.Int32,Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithMass(System.Single)">
            <summary>
            Total mass of the physics body (Default is 1000)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithSurface(System.String)">
            <summary>
            Surface property to use for collision
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithLodDistance(System.Single)">
            <summary>
            LOD switch distance increment for each LOD level (Default is 50)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionBox(Vector3,System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Add box collision shape
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionSphere(System.Single,Vector3)">
            <summary>
            Add sphere collision shape
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionCapsule(Vector3,Vector3,System.Single)">
            <summary>
            Add capsule collision shape
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionHull(Vector3[],System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Add a CONVEX hull collision shape
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionMesh(Vector3[],System.Int32[])">
            <summary>
            Add a CONCAVE mesh collision shape (This shape can NOT be physically simulated)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh)">
            <summary>
            Add a mesh
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMeshes(Sandbox.Mesh[])">
            <summary>
            Add a bunch of meshes
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh,System.Int32)">
            <summary>
            Add a mesh to a LOD group
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMeshes(Sandbox.Mesh[],System.Int32)">
            <summary>
            Add a bunch of meshes to a LOD group
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddBone(System.String,Vector3,Rotation,System.String)">
            <summary>
            Add a bone to the skeleton
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.Create">
            <summary>
            Finish creation of model
            </summary>
        </member>
        <member name="M:Sandbox.Model.Get(NativeEngine.CModel)">
            <summary>
            Try to make it so only one Model class exists for each model
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetVertices">
            <summary>
            Experimental! Try to get all vertices from model (meshes need to be compiled with CPU access!)
            https://files.facepunch.com/layla/1b0611b1/sbox_K1HhsZO3yM.png
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetIndices">
            <summary>
            Experimental! Try to get all indices from model (meshes need to be compiled with CPU access!)
            https://files.facepunch.com/layla/1b0611b1/sbox_K1HhsZO3yM.png
            </summary>
        </member>
        <member name="M:Sandbox.Render.GetDynamicVB(System.Boolean)">
            <summary>
            Get the vertex buffer
            </summary>
        </member>
        <member name="M:Sandbox.Render.CopyFrameBuffer">
            <summary>
            Grabs the current frame buffer and stores it in 'FrameBufferCopyTexture'
            </summary>
        </member>
        <member name="M:Sandbox.RenderingManager.RenderUI(NativeEngine.ISceneView,NativeEngine.IRenderContext,NativeEngine.ISceneLayer)">
            <summary>
            Called from render thread
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CopyFrom(Sandbox.Texture)">
            <summary>
            Replace our strong handle with a copy of the strong handle of the passed texture
            Which means that this texture will invisbly become that texture.
            I suspect that there might be a decent way to do this in native using the resource system.
            In which case we should change all this code to use that way instead of doing this.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Dispose">
            <summary>
            Will release the handle for this texture. If the texture isn't referenced by anything
            else it'll be released properly. This will happen anyway because it's called in the destructor.
            By calling it manually you're just telling the engine you're done with this texture right now
            instead of waiting for the garbage collector.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.LoadAsync(System.String,System.Boolean)">
            <summary>
            Load a texture asyncronously. Will return when the texture is loaded and valid.
            This is useful when loading textures from the web.
            </summary>
        </member>
        <member name="F:Sandbox.TextureLoader.ImageUrl.Loaded">
            <summary>
            For textures loaded from the web we want to keep them around a bit longer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.Add(Sandbox.Vertex)">
            <summary>
            Add a vertex
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddIndex(System.Int32)">
            <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count., 1 is Vertex.Count -1
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddTriangleIndex(System.Int32,System.Int32,System.Int32)">
            <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddRawIndex(System.Int32)">
            <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.Draw(Sandbox.Material)">
            <summary>
            Draw this mesh using Material
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.ExcludeGameLayer">
            <summary>
            Don't render in the opaque/translucent game passes. This is useful when you
            want to only render in the Bloom layer, rather than additionally to it.
            </summary>
        </member>
        <member name="P:Sandbox.Time.Now">
            <summary>
            The time since game startup
            </summary>
        </member>
        <member name="P:Sandbox.Time.Delta">
            <summary>
            The delta between the last frame and the current (for all intents and purposes)
            </summary>
        </member>
        <member name="P:Sandbox.Time.Tick">
            <summary>
            The current tick number that is being simulated.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.UseHitboxes(System.Boolean)">
            <summary>
            Adds CollisionLayer.Hitbox to the mask
            </summary>
        </member>
        <member name="M:Sandbox.Trace.HitLayer(Sandbox.CollisionLayer,System.Boolean)">
            <summary>
            Adds CollisionLayer.Water to the mask
            </summary>
        </member>
        <member name="M:Sandbox.Trace.WithTag(System.String)">
            <summary>
            Only return entities with this tag. Subsequent calls to this will add multiple requirements
            and they'll all have to be met (ie, the entity will need all tags).
            </summary>
        </member>
        <member name="M:Sandbox.Trace.WithAllTags(System.String[])">
            <summary>
            Only return entities with all of these tags
            </summary>
        </member>
        <member name="M:Sandbox.Trace.WithAnyTags(System.String[])">
            <summary>
            Only return entities with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.Trace.WithoutTags(System.String)">
            <summary>
            Only return entities with none of these tags
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Hit">
            <summary>
            Whether the trace hit something or not
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.StartedSolid">
            <summary>
            Whether the trace started in a solid
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.StartPos">
            <summary>
            The start position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.EndPos">
            <summary>
            The end or hit position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Normal">
            <summary>
            The hit surface normal (direction vector)
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Fraction">
            <summary>
            A fraction [0..1] of where the trace hit between the start and the original end positions
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Entity">
            <summary>
            The entity that was hit, if any
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Body">
            <summary>
            The physics object that was hit, if any
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Shape">
            <summary>
            TODO
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.HitboxIndex">
            <summary>
            TODO
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Surface">
            <summary>
            The properties of the hit surface
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Bone">
            <summary>
            The id of the hit bone (either from hitbox or physics shape)
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Direction">
            <summary>
            The direction of the trace ray
            </summary>
        </member>
        <member name="P:Sandbox.UI.DataSource.BaseDataSource.PropertyName">
            <summary>
            Property on Panel to bind to.
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.BaseDataSource.Hash">
            <summary>
            Hash to store the last value in, to avoid unnesssary updates
            </summary>
        </member>
        <member name="P:Sandbox.UI.DataSource.BaseDataSource.Value">
            <summary>
            Implementable to get/set the value from the bound object
            </summary>
        </member>
        <member name="M:Sandbox.UI.DataSource.BaseDataSource.TryUpdateHash(System.Object)">
            <summary>
            Returns true if the hash changed
            </summary>
        </member>
        <member name="M:Sandbox.UI.DataSource.BaseDataSource.Tick(Sandbox.UI.Panel)">
            <summary>
            Set the panel property from whatever the value is
            </summary>
        </member>
        <member name="T:Sandbox.UI.DataSource.ObjectProperty">
            <summary>
            Bind a panel property to an object property ([Target].[TargetProperty])
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.ObjectProperty.Target">
            <summary>
            The target object to find the property
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.ObjectProperty.TargetProperty">
            <summary>
            Target source, ie "PlayerName"
            </summary>
        </member>
        <member name="M:Sandbox.UI.Clipboard.SetText(System.String)">
            <summary>
            Sets the clipboard text
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.SetText(System.String)">
            <summary>
            Calls Text = value
            </summary>
        </member>
        <member name="M:Sandbox.UI.LayoutCascade.ApplyCascading(Sandbox.UI.Styles)">
            <summary>
            Some properties cascade from their parent onto children if the children
            don't set them. Things like font size, color, cursor.
            </summary>
        </member>
        <member name="T:Sandbox.UI.TransitionDesc">
            <summary>
            Utility to create a transition by comparing the 
            panel style before and after the scope
            </summary>
        </member>
        <member name="T:Sandbox.UI.TransitionList">
            <summary>
            Utility to create a transition by comparing the 
            panel style before and after the scope
            </summary>
        </member>
        <member name="M:Sandbox.UI.FontManager.TryToLoad(System.String,System.Single,System.String)">
            <summary>
            Try to find this font on disk
            </summary>
        </member>
        <member name="M:Sandbox.UI.FontManager.WeightToText(System.Single)">
            <summary>
            Given a number, return the closest name weight
            </summary>
        </member>
        <member name="M:Sandbox.UI.SkiaTextBlock.Render(Sandbox.UI.PanelRenderer,Sandbox.UI.RenderState@,Sandbox.UI.Styles,Rect)">
            <summary>
            Proper Rendering
            </summary>
        </member>
        <member name="M:Sandbox.UI.SkiaTextBlock.SizeFinalized(System.Single,System.Single)">
            <summary>
            Called on layout. We should decide here if we actually need to rebuild
            </summary>
        </member>
        <member name="M:Sandbox.UI.SkiaTextBlock.RebuildTexture(System.Single,System.Single)">
            <summary>
            Actually recreate the texture
            </summary>
        </member>
        <member name="P:Sandbox.UI.Input.Hovered">
            <summary>
            Panel we're currently hovered over
            </summary>
        </member>
        <member name="P:Sandbox.UI.Input.Active">
            <summary>
            Panel we're currently pressing down
            </summary>
        </member>
        <member name="M:Sandbox.UI.Input.SetCursor(System.String)">
            <summary>
            The cursor should change. Name could be null, meaning default.
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse0">
            <summary>
            Left Mouse Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse1">
            <summary>
            Muddle Mouse Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse2">
            <summary>
            Right Mouse Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse3">
            <summary>
            Back Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse4">
            <summary>
            Forward Button
            </summary>
        </member>
        <member name="M:Sandbox.UI.InputFocus.Set(Sandbox.UI.Panel)">
            <summary>
            Set the focus to this panel (or its nearest ancestor with AcceptsFocus).
            Note that Current won't change until the next frame.
            </summary>
        </member>
        <member name="M:Sandbox.UI.InputFocus.Clear(Sandbox.UI.Panel)">
            <summary>
            Clear focus away from this panel.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.activeRules">
            <summary>
            This could be a local variable if we wanted to create a new class every time
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.LastActiveRules">
            <summary>
            Store the last active rules so we can compare them when they change and trigger sounds etc on new styles
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.ActiveRulesGuid">
            <summary>
            Cache of the active rules that are applied, that way we can trigger stuff only if they actually changed
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.RemoveChild(Sandbox.UI.Panel)">
            <summary>
            Called internally when a child is removed, to remove from our Children list
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnChildRemoved(Sandbox.UI.Panel)">
            <summary>
            A child panel has been removed from this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddChild(Sandbox.UI.Panel)">
            <summary>
            Add a child to this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.InternalAddChild(Sandbox.UI.Panel)">
            <summary>
            Called internally when a child is added, to add to our Children list
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnChildAdded(Sandbox.UI.Panel)">
            <summary>
            A child panel has been added to this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SortChildren(System.Comparison{Sandbox.UI.Panel})">
            <summary>
            Sort the children using this comparison function
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SortChildren``1(System.Func{``0,System.Int32})">
            <summary>
            Sort the children using this comparison function
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SortChildren(System.Func{Sandbox.UI.Panel,System.Int32})">
            <summary>
            Sort the children using this comparison function
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.IsAncestor(Sandbox.UI.Panel)">
            <summary>
            Is the passed panel a parent, grandparent etc
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Class">
            <summary>
            A list of classes applied to this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddClass(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.RemoveClass(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.HasClass(System.String)">
            <summary>
            Returns true if we have this class
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DirtyStylesRecursive">
            <summary>
            Dirty the styles of this class and its children recursively.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ElementName">
            <summary>
            The element name. If you've created this Panel via a template this will be whatever the element
            name is on there. If not then it'll be the name of the class (ie Panel, Button)
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.PseudoClass">
            <summary>
            Special flags used by the styling system for hover, active etc..
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Switch(Sandbox.UI.PseudoClass,System.Boolean)">
            <summary>
            Switch a pseudo class on or off
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.IsVisible">
            <summary>
            Return true if this panel isn't hidden by opacity
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnParentChanged">
            <summary>
            Called after the parent has changed
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ScreenPositionToPanelDelta(Vector2)">
            <summary>
            Convert a point from the screen to a point representing a delta on this panel where
            the top left is [0,0] and the bottom right is [1,1]
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ScreenPositionToPanelPosition(Vector2)">
            <summary>
            Convert a point from the screen to a position relative to the top left of this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.CreateValueEvent(System.String,System.Object)">
            <summary>
            Call this when the value has changed due to user input etc. This updates any
            bindings, backwards.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Delete(System.Boolean)">
            <summary>
            Deletes the panel. If immediate is set, will skip any outros.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnDeleteRecursive">
            <summary>
            Called on delete
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.MousePosition">
            <summary>
            Current mouse position local to this panel
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.AcceptsFocus">
            <summary>
            Default by false, can this element accept focus. If an element accepts
            focus it'll be able to recieve keyboard input.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Blur">
            <summary>
            Stop being the focus
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.GetClipboardValue(System.Boolean)">
            <summary>
            If we have a value that can be copied to the clipboard, return it here.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.UI.Panel.PushLayer(Sandbox.UI.PanelRenderer)">
            <summary>
            Called before rendering this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PopLayer(Sandbox.UI.PanelRenderer)">
            <summary>
            called after rendering this panel
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel.YogaScale">
            <summary>
            Any values fed to Yoga are multipled by this value, any returned are divided by this value.
            This is because Yoga snaps to pixels and it looks bad with HUD elements, so we add a bit of 
            sub-pixel allowance. 
            (We might end up having to snap text etc to pixels to stop it being blurry but that's in our control)
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.LocalMatrix">
            <summary>
            If this panel has transforms, they'll be reflected here
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.GlobalMatrix">
            <summary>
            If this panel or its parents have transforms, they'll be compounded here.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FinalLayout">
            <summary>
            Takes a LayoutCascade and returns an outer rect
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.PreferScrollToBottom">
            <summary>
            If true, we'll try to stay scrolled to the bottom when the panel changes size
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetBindProperty(Sandbox.UI.Panel,System.String,System.String)">
            <summary>
            Binds that are generated via @ attributes in the templating system
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Bind(System.String,System.Object,System.String)">
            <summary>
            Bind to the target object's property
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Bind(Sandbox.UI.DataSource.BaseDataSource)">
            <summary>
            Bind to the data source
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetRefProperty(Sandbox.UI.Panel,System.String,System.String)">
            <summary>
            Sets the field on context
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetContent(System.String)">
            <summary>
            Called by the templating system when an element has content between its tags.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnTemplateElement(Sandbox.Html.INode)">
            <summary>
            If you return true to this call the children from this element won't be created
            because we'll assume you're doing it youself in your control code
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetTemplate(System.String)">
            <summary>
            Set the panel's template. Ideally you won't be using this, you'll be 
            using the [UseTemplate] attribute instead.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ComputedStyle">
            <summary>
            This is the style that we computed last. If you're looking to see which
            styles are set on this panel then this is what you're looking for.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Style">
            <summary>
            Allows you to set styles specifically on this panel. Setting the style will
            only affect this panel and no others and will override any other styles.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PreTemplateApplied">
            <summary>
            Called right before the template is applied.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PostTemplateApplied">
            <summary>
            Called right after the template is applied
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Transitions">
            <summary>
            Handles the storage, progression and application of style transitions
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasActiveTransitions">
            <summary>
            Return true if this panel has any active transitions
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SkipTransitions">
            <summary>
            Any traisitons running, or about to run, will jump straight to the end
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleParser.ParseStyles(System.String,Sandbox.UI.Styles)">
            <summary>
            Parse the styles as you would if they were passed in an sytle="width: 100px" attribute
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleParser.Selector(System.String,Sandbox.UI.StyleBlock)">
            <summary>
            Here we divide the selectors into groups
            .fucker, .cocks, .hairy
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleParser.ParseSingleSelector(System.String,Sandbox.UI.StyleBlock)">
            <summary>
            Parse a single rule, which as "panel.closed.error:hover"
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.UI.BaseTextBlock.CaretRect(System.Int32)">
            <summary>
            Given a character position, where is the fucking caret
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelRenderer.Render(Sandbox.UI.Panel,Sandbox.UI.RenderState)">
            <summary>
            Render a panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelRenderer.DrawBoxShadow(Sandbox.UI.Panel,Sandbox.UI.RenderState@)">
            <summary>
            Should draw the box shadow, if your renderer supports this
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelRenderer.GetTextBlock(Sandbox.UI.Styles,Sandbox.UI.BaseTextBlock)">
            <summary>
            Get or reuse a text block
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.WantsMouseInput">
            <summary>
            If any of our panels are visible and want mouse input (pointer-events != none) then 
            this will be set to the first panel we find where that is the case
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.UpdateScale(Rect)">
            <summary>
            Work out scaling here. Default is to scale relative to the screen being
            1920 wide. ie - scale = screensize.Width / 1920.0f;
            </summary>
        </member>
        <member name="T:Sandbox.UI.StyleBlock">
            <summary>
            A CSS rule - ie ".chin { width: 100%; height: 100%; }"
            </summary>
        </member>
        <member name="F:Sandbox.UI.Justify.FlexStart">
            <summary>
            [OOOO            ]
            </summary>
        </member>
        <member name="F:Sandbox.UI.Justify.SpaceBetween">
            <summary>
            [O    O    O    O]
            </summary>
        </member>
        <member name="T:Sandbox.UI.StyleSelector">
            <summary>
            A CSS selector like "Panel.button.red:hover .text"
            </summary>
        </member>
        <member name="F:Sandbox.UI.StyleSelector.Parent">
            <summary>
            Descendant combinator
            A B
            Child combinator
            A > B
            Adjacent sibling combinator
            A + B
            General sibling combinator
            A ~B
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheet.InitStyleSheets">
            <summary>
            Between sessions we clear the stylesheets, so one gamemode can't accidentally
            use cached values from another.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheet.Release">
            <summary>
            Releases the filesystem watcher so we won't get file changed events.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Add(Sandbox.UI.StyleSheet)">
            <summary>
            Add a stylesheet directly
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Load(System.String,System.Boolean)">
            <summary>
            Load the stylesheet from a file
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Parse(System.String,System.Boolean)">
            <summary>
            Load the stylesheet from a string
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelAction.Parse(System.String,System.String,System.Collections.Generic.List{Sandbox.UI.PanelAction})">
            <summary>
            Parse the code line into multiple PanelActions
            </summary>
        </member>
        <member name="T:Sandbox.UI.PanelAction.Argument">
            <summary>
            This is a mechanism to pass in possibly dynamic arguments
            </summary>
        </member>
        <member name="T:Sandbox.UI.PanelAction.StringLiteralArgument">
            <summary>
            A string literal means that the argument is just a static string, passed in 'liek this
            </summary>
        </member>
        <member name="T:Sandbox.UI.PanelAction.RuntimeArgument">
            <summary>
            A string literal means that the argument is just a static string, passed in 'liek this
            </summary>
        </member>
        <member name="T:Sandbox.UI.UseTemplateAttribute">
            <summary>
            If no name is passed, we will look next to the name of the file with this attribute
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.Apply(Sandbox.UI.Panel)">
            <summary>
            Applies the layout to this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.ApplyStyles(Sandbox.UI.Panel)">
            <summary>
            Applies styles in this layout to this panel
            Since styles are applied to the root, this could
            and would obviously affect children too
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.Unapply(Sandbox.UI.Panel,System.Boolean)">
            <summary>
            Tries to remove the effects of this layout
            from this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.Forget(Sandbox.UI.Panel)">
            <summary>
            Stop tracking this panel as part of the layout.
            This means it'll stop getting notified of layout changes
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.RemoveStyles(Sandbox.UI.Panel)">
            <summary>
            Remove any styles applied by this layout
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.Load(System.String)">
            <summary>
            Load the layout from a string of html
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.AddStyleLink(System.String)">
            <summary>
            Adds a link to a stylesheet for this layout
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.AddStyleString(System.String)">
            <summary>
            Adds some raw css to our style for this layout
            </summary>
        </member>
        <member name="T:Sandbox.AddonProvision.Utility">
            <summary>
            Downloading and getting information about a specific addon.
            </summary>
            <summary>
            Downloading and getting information about a specific addon.
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlay.Skeleton(Sandbox.Entity,Color,System.Single,System.Boolean)">
            <summary>
            Draw this entity's skeleton ( if it has one)
            Will return false if it didn't manage to draw a skeleton.
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlay.Box(Sandbox.Entity,Color,System.Single)">
            <summary>
            Draw an entity bounds
            </summary>
        </member>
        <member name="M:Sandbox.DebugOverlay.Box(Sandbox.PhysicsBody,Color,System.Single)">
            <summary>
            Draw a physics object bounds
            </summary>
        </member>
        <member name="T:Sandbox.Easing">
            <summary>
            Easing functions used for transitions
            </summary>
        </member>
        <member name="T:Sandbox.Easing.Function">
            <summary>
            An easing function that transforms the linear input into non linear output.
            </summary>
            <param name="delta">A linear input value from 0 to 1</param>
            <returns>The resulting non linear output value, from 0 to 1</returns>
        </member>
        <member name="M:Sandbox.Easing.AddFunction(System.String,Sandbox.Easing.Function)">
            <summary>
            Add an easing function. 
            If the function already exists we silently return.
            </summary>
        </member>
        <member name="M:Sandbox.Easing.GetFunction(System.String)">
            <summary>
            Get an easing function by name (ie, "ease-in").
            If the function doesn't exist we return QuadraticInOut
            </summary>
        </member>
        <member name="M:Sandbox.Event.RegisterAssembly(System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            Register an assembly. If old assembly is valid, we try to remove all of the old event hooks
            from this assembly, while retaining a list of objects.
            </summary>
        </member>
        <member name="M:Sandbox.Event.Register(System.Object)">
            <summary>
            Register an object to start recieving events
            </summary>
        </member>
        <member name="M:Sandbox.Event.Unregister(System.Object)">
            <summary>
            Unregister an object, stop reciving events
            </summary>
        </member>
        <member name="M:Sandbox.Event.Run(System.String)">
            <summary>
            Run an event
            </summary>
        </member>
        <member name="M:Sandbox.Event.Run``1(System.String,``0)">
            <summary>
            Run an event
            </summary>
        </member>
        <member name="M:Sandbox.Event.Run``2(System.String,``0,``1)">
            <summary>
            Run an event
            </summary>
        </member>
        <member name="T:Sandbox.LoopEvent">
            <summary>
            This class will call any static methods with an attribute on, in THIS dll (sandbox.game.dll).
            This is used so systems can clean themselves on init and shutdown.
            </summary>
        </member>
        <member name="T:Sandbox.ReflectionCache">
            <summary>
            This cache might be fucking stupid
            </summary>
        </member>
        <member name="M:Sandbox.ReflectionCache.GetAllMethods(System.Type,System.Collections.Generic.List{System.Reflection.MethodInfo})">
            <summary>
            Get all methods in this type, including private ones, including repeats
            </summary>
        </member>
        <member name="M:Sandbox.Screen.GetDirection(Vector2)">
            <summary>
            Gives a direction bector based on the position of the point on the screen
            </summary>
        </member>
        <member name="M:Sandbox.Screen.GetDirection(Vector2,System.Single)">
            <summary>
            Gives a direction bector based on the position of the point on the screen
            </summary>
        </member>
        <member name="M:Sandbox.Screen.GetDirection(Vector2,System.Single,Rotation)">
            <summary>
            Gives a direction bector based on the position of the point on the screen
            </summary>
        </member>
        <member name="M:Sandbox.Screen.GetDirection(Vector2,System.Single,Rotation,Vector2)">
            <summary>
            Gives a direction bector based on the position of the point on the screen.
            </summary>
        </member>
        <member name="T:Sandbox.TaskSource">
            <summary>
            Provides a way for us to cancel tasks after common async shit is executed
            </summary>
        </member>
        <member name="T:Sandbox.WebSocket">
            <summary>
            A WebSocket client for connecting to external services.
            </summary>
            <remarks>
            Events handlers will be called on the synchronization context that <see cref="M:Sandbox.WebSocket.Connect(System.String,System.Threading.CancellationToken)"/> was called on.
            </remarks>
        </member>
        <member name="T:Sandbox.WebSocket.MessageReceivedHandler">
            <summary>
            Event handler which processes text messages from the WebSocket service.
            </summary>
            <param name="message">The message text that was received.</param>
        </member>
        <member name="T:Sandbox.WebSocket.DataReceivedHandler">
            <summary>
            Event handler which processes binary messages from the WebSocket service.
            </summary>
            <param name="data">The binary message data that was received.</param>
        </member>
        <member name="T:Sandbox.WebSocket.DisconnectedHandler">
            <summary>
            Event handler which fires when the WebSocket disconnects from the server.
            </summary>
            <param name="status">The close status code from the server, or 0 if there was none. See known values here: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent</param>
            <param name="reason">The reason string for closing the connection. This may not be populated, may be from the server, or may be a client exception message.</param>
        </member>
        <member name="P:Sandbox.WebSocket.IsConnected">
            <summary>
            Returns true as long as a WebSocket connection is established.
            </summary>
        </member>
        <member name="P:Sandbox.WebSocket.SubProtocol">
            <summary>
            Get the sub-protocol that was negotiated during the opening handshake.
            </summary>
        </member>
        <member name="E:Sandbox.WebSocket.OnMessageReceived">
            <summary>
            Event which fires when a text message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.WebSocket.OnDataReceived">
            <summary>
            Event which fires when a binary message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.WebSocket.OnDisconnected">
            <summary>
            Event which fires when the connection to the WebSocket service is lost, for any reason.
            </summary>
        </member>
        <member name="M:Sandbox.WebSocket.#ctor(System.Int32)">
            <summary>
            Initialized a new WebSocket client.
            </summary>
            <param name="maxMessageSize">The maximum message size to allow from the server, in bytes. Default 64 KiB.</param>
        </member>
        <member name="M:Sandbox.WebSocket.Dispose">
            <summary>
            Cleans up resources used by the WebSocket client. This will also immediately close the connection if it is currently open.
            </summary>
        </member>
        <member name="M:Sandbox.WebSocket.AddSubProtocol(System.String)">
            <summary>
            Add a sub-protocol to be negotiated during the WebSocket connection handshake.
            </summary>
            <param name="protocol"></param>
        </member>
        <member name="M:Sandbox.WebSocket.Connect(System.String,System.Threading.CancellationToken)">
            <summary>
            Establishes a connection to an external WebSocket service.
            </summary>
            <param name="websocketUri">The WebSocket URI to connect to. For example, "ws://hostname.local:1280/" for unencrypted WebSocket or "wss://hostname.local:1281/" for encrypted.</param>
            <param name="ct">A <see cref="T:System.Threading.CancellationToken"/> which allows the connection attempt to be aborted if necessary.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> which completes when the connection is established, or throws if it failed to connect.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.String)">
            <summary>
            Sends a text message to the WebSocket server.
            </summary>
            <param name="message">The message text to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.Byte[])">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <remarks>
            The <see cref="M:Sandbox.WebSocket.Send(System.ArraySegment{System.Byte})"/> and <see cref="M:Sandbox.WebSocket.Send(System.Span{System.Byte})"/> overloads allow sending subsections of byte arrays.
            </remarks>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.ArraySegment{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.Span{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.SHOULD_BE_DELETED_BEFORE_WORLD">
            For objects that can't be considered to be "owned" by the world they are in because they
            are owned by a manager. All this flag does is cause a warning when such an object is still
            in the world at world deletion time (a leak).
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.OWNED_BY_ANOTHER_SCENEOBJECT">
            if this flag is set, then the object will not be deleted when deleting the world, and will not be queued for delete. It's assumed that this object is going to be deleted inside of the destructor of another sceneobject
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.PARTIALLY_ALPHA_BLENDED">
            We have a mixture of alpha-blended and non-alpha blended draws
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.UNIQUE_BATCH_GROUP">
            A unique batch flag that allows objects to draw in a separate batch from their original group
        </member>
        <member name="F:NativeEngine.TraceRequest.ResolveEntities">
            <summary>
            If true, we use a slightly slower path in the trace code that checks each entity.
            This is needed for testing things like Tags, so gets set automatically if needed.
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsBody.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsBody.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_f2(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsGroup.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_f3(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsGroup.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_f4(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsJoint.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_f5(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsJoint.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_f6(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsShape.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_f7(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsShape.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_SceneO_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneObject.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_SceneO_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneObject.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_SceneW_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneWorld.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_SceneW_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneWorld.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnNameChanged(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalOnNameChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_OnNativeEntity(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.OnNativeEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalDestruct(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalDestruct( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalUpdateOnRemove(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalUpdateOnRemove( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_EnterPVSInternal(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.EnterPVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_LeavePVSInternal(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.LeavePVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalClientCreated(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalClientCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalClientActivate(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalClientActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalEntityKeyValue(System.IntPtr,System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalEntityKeyValue( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalEntityConnection(System.IntPtr,System.IntPtr,NativeEngine.EntityIOTargetType,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalEntityConnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalSpawn(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalSpawn( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalStartTouch(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalStartTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnTouch(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalOnTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalEndTouch(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalEndTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnParentChanged(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalOnParentChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalPreDataUpdate(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalPreDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalPostDataUpdate(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalPostDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnNewModel(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalOnNewModel( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalAnimEvent(System.IntPtr,System.IntPtr,System.Int32,System.Single,Vector3,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalAnimEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalAnimEventFootstep(System.IntPtr,Vector3,System.Int32,System.Single)">
            <summary>
            Sandbox.ClientEntity.InternalAnimEventFootstep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalPostClientActive(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalPostClientActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_PredictionStore(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionStore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_PredictionRestore(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionRestore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_PredictionVerify(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionVerify( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_PredictionDestroy(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.PredictionDestroy( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_PredictionShift(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionShift( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalMoveDone(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalMoveDone( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalMoveBlocked(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalMoveBlocked( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnSetDormant(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalOnSetDormant( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalPhysicsCollisionEvent(System.IntPtr,System.IntPtr,Vector3,Vector3,Vector3,Vector3,Vector3,Vector3,System.Single)">
            <summary>
            Sandbox.ClientEntity.InternalPhysicsCollisionEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_PlayerSetupVisibility(System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.PlayerSetupVisibility( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_CnsleS_DispatchCommand(System.IntPtr,System.IntPtr,System.Int64,System.Int32)">
            <summary>
            Sandbox.ConsoleSystem.DispatchCommand( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_OnNativeEntity(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Entity.OnNativeEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalDestruct(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalDestruct( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalUpdateOnRemove(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalUpdateOnRemove( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_EnterPVSInternal(System.IntPtr)">
            <summary>
            Sandbox.Entity.EnterPVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_LeavePVSInternal(System.IntPtr)">
            <summary>
            Sandbox.Entity.LeavePVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalClientCreated(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalClientCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalClientActivate(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalClientActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalEntityKeyValue(System.IntPtr,System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Entity.InternalEntityKeyValue( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalEntityConnection(System.IntPtr,System.IntPtr,NativeEngine.EntityIOTargetType,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32)">
            <summary>
            Sandbox.Entity.InternalEntityConnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalSpawn(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalSpawn( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalStartTouch(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalStartTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalOnTouch(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalOnTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalEndTouch(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalEndTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalOnParentChanged(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalOnParentChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalPreDataUpdate(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalPreDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalPostDataUpdate(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalPostDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalOnNewModel(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalOnNewModel( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalAnimEvent(System.IntPtr,System.IntPtr,System.Int32,System.Single,Vector3,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalAnimEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalAnimEventFootstep(System.IntPtr,Vector3,System.Int32,System.Single)">
            <summary>
            Sandbox.Entity.InternalAnimEventFootstep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalPostClientActive(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalPostClientActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_PredictionStore(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionStore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_PredictionRestore(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionRestore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_PredictionVerify(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionVerify( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_PredictionDestroy(System.IntPtr)">
            <summary>
            Sandbox.Entity.PredictionDestroy( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_PredictionShift(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionShift( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalMoveDone(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalMoveDone( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalMoveBlocked(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalMoveBlocked( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalOnSetDormant(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Entity.InternalOnSetDormant( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalPhysicsCollisionEvent(System.IntPtr,System.IntPtr,Vector3,Vector3,Vector3,Vector3,Vector3,Vector3,System.Single)">
            <summary>
            Sandbox.Entity.InternalPhysicsCollisionEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_PlayerSetupVisibility(System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Sandbox.Entity.PlayerSetupVisibility( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_EnttyM_CreateServerEntity(System.IntPtr)">
            <summary>
            Sandbox.EntityManager.CreateServerEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_EnttyM_CreateClientsideOfNetworkedEntity(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.EntityManager.CreateClientsideOfNetworkedEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PostCreateInterface">
            <summary>
            Sandbox.GameLoop.PostCreateInterface( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_Init">
            <summary>
            Sandbox.GameLoop.Init( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PreOnActivate">
            <summary>
            Sandbox.GameLoop.PreOnActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PostOnActivate">
            <summary>
            Sandbox.GameLoop.PostOnActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_OnDeactivate">
            <summary>
            Sandbox.GameLoop.OnDeactivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_LoopShutdown">
            <summary>
            Sandbox.GameLoop.LoopShutdown( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_ClientPutInServer(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.GameLoop.ClientPutInServer( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_ClientDisconnected(System.Int32,System.Int32,System.IntPtr,System.UInt64,System.IntPtr)">
            <summary>
            Sandbox.GameLoop.ClientDisconnected( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_OnClientPreOutput">
            <summary>
            Sandbox.GameLoop.OnClientPreOutput( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_OnClientPostOutput">
            <summary>
            Sandbox.GameLoop.OnClientPostOutput( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_GetView(System.IntPtr)">
            <summary>
            Sandbox.GameLoop.GetView( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PreRender">
            <summary>
            Sandbox.GameLoop.PreRender( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PhysicsThink">
            <summary>
            Sandbox.GameLoop.PhysicsThink( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PrePhysicsStep(System.Single)">
            <summary>
            Sandbox.GameLoop.PrePhysicsStep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PostPhysicsStep(System.Single)">
            <summary>
            Sandbox.GameLoop.PostPhysicsStep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PhysicsImpactSound(System.Int32,Vector3,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Sandbox.GameLoop.PhysicsImpactSound( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_OnPhysicsJointBreak(System.Int32)">
            <summary>
            Sandbox.GameLoop.OnPhysicsJointBreak( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_ServerFrame_Think">
            <summary>
            Sandbox.GameLoop.ServerFrame_Think( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_ClientFrame_Think">
            <summary>
            Sandbox.GameLoop.ClientFrame_Think( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_InptBl_Process(System.IntPtr)">
            <summary>
            Sandbox.InputBuilder.Process( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Netwrk_OnNetMessage(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sandbox.Networking.OnNetMessage( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_PlyerC_RunClient(System.IntPtr,NativeEngine.CUserCmd)">
            <summary>
            Sandbox.PlayerCommand.RunClient( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_PlyerC_RunServer(System.IntPtr,NativeEngine.CUserCmd)">
            <summary>
            Sandbox.PlayerCommand.RunServer( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Predct_PreEntityPacketReceived(System.Int32,System.Int32)">
            <summary>
            Sandbox.Prediction.PreEntityPacketReceived( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Predct_PostEntityPacketReceived">
            <summary>
            Sandbox.Prediction.PostEntityPacketReceived( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_RelTme_Update(System.Single)">
            <summary>
            Sandbox.RealTime.Update( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Render_RenderUI(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.RenderingManager.RenderUI( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Render_RenderSceneObjects(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.RenderingManager.RenderSceneObjects( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_StrngT_Init">
            <summary>
            Sandbox.StringTables.Init( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_StrngT_Shutdown">
            <summary>
            Sandbox.StringTables.Shutdown( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Time_Update(System.Single,System.Single,System.Int32)">
            <summary>
            Sandbox.Time.Update( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Stemwr_Dsptch_OnClientCallback(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Steamworks.Dispatch.OnClientCallback( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceMenu.Exports.Sandbomenu_SceneO_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneObject.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceMenu.Exports.Sandbomenu_SceneO_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneObject.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceMenu.Exports.Sandbomenu_SceneW_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneWorld.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceMenu.Exports.Sandbomenu_SceneW_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneWorld.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceMenu.Exports.Sandbo_MenInt_RenderUI(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.MenuInterface.RenderUI( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnNameChanged(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalOnNameChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_OnNativeEntity(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.OnNativeEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalDestruct(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalDestruct( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalUpdateOnRemove(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalUpdateOnRemove( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_EnterPVSInternal(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.EnterPVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_LeavePVSInternal(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.LeavePVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalClientCreated(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalClientCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalClientActivate(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalClientActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalEntityKeyValue(System.IntPtr,System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalEntityKeyValue( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalEntityConnection(System.IntPtr,System.IntPtr,NativeEngine.EntityIOTargetType,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalEntityConnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalSpawn(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalSpawn( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalStartTouch(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalStartTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnTouch(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalOnTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalEndTouch(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalEndTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnParentChanged(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalOnParentChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalPreDataUpdate(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalPreDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalPostDataUpdate(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalPostDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnNewModel(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalOnNewModel( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalAnimEvent(System.IntPtr,System.IntPtr,System.Int32,System.Single,Vector3,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalAnimEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalAnimEventFootstep(System.IntPtr,Vector3,System.Int32,System.Single)">
            <summary>
            Sandbox.ClientEntity.InternalAnimEventFootstep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalPostClientActive(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalPostClientActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_PredictionStore(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionStore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_PredictionRestore(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionRestore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_PredictionVerify(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionVerify( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_PredictionDestroy(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.PredictionDestroy( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_PredictionShift(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionShift( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalMoveDone(System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalMoveDone( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalMoveBlocked(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalMoveBlocked( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnSetDormant(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalOnSetDormant( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalPhysicsCollisionEvent(System.IntPtr,System.IntPtr,Vector3,Vector3,Vector3,Vector3,Vector3,Vector3,System.Single)">
            <summary>
            Sandbox.ClientEntity.InternalPhysicsCollisionEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_PlayerSetupVisibility(System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.PlayerSetupVisibility( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_CnsleS_DispatchCommand(System.IntPtr,System.IntPtr,System.Int64,System.Int32)">
            <summary>
            Sandbox.ConsoleSystem.DispatchCommand( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_OnNativeEntity(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Entity.OnNativeEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalDestruct(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalDestruct( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalUpdateOnRemove(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalUpdateOnRemove( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_EnterPVSInternal(System.IntPtr)">
            <summary>
            Sandbox.Entity.EnterPVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_LeavePVSInternal(System.IntPtr)">
            <summary>
            Sandbox.Entity.LeavePVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalClientCreated(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalClientCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalClientActivate(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalClientActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalEntityKeyValue(System.IntPtr,System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Entity.InternalEntityKeyValue( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalEntityConnection(System.IntPtr,System.IntPtr,NativeEngine.EntityIOTargetType,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32)">
            <summary>
            Sandbox.Entity.InternalEntityConnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalSpawn(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalSpawn( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalStartTouch(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalStartTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalOnTouch(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalOnTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalEndTouch(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalEndTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalOnParentChanged(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalOnParentChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalPreDataUpdate(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalPreDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalPostDataUpdate(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalPostDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalOnNewModel(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalOnNewModel( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalAnimEvent(System.IntPtr,System.IntPtr,System.Int32,System.Single,Vector3,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalAnimEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalAnimEventFootstep(System.IntPtr,Vector3,System.Int32,System.Single)">
            <summary>
            Sandbox.Entity.InternalAnimEventFootstep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalPostClientActive(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalPostClientActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_PredictionStore(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionStore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_PredictionRestore(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionRestore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_PredictionVerify(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionVerify( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_PredictionDestroy(System.IntPtr)">
            <summary>
            Sandbox.Entity.PredictionDestroy( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_PredictionShift(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionShift( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalMoveDone(System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalMoveDone( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalMoveBlocked(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalMoveBlocked( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalOnSetDormant(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Entity.InternalOnSetDormant( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalPhysicsCollisionEvent(System.IntPtr,System.IntPtr,Vector3,Vector3,Vector3,Vector3,Vector3,Vector3,System.Single)">
            <summary>
            Sandbox.Entity.InternalPhysicsCollisionEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_PlayerSetupVisibility(System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Sandbox.Entity.PlayerSetupVisibility( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_EnttyM_CreateServerEntity(System.IntPtr)">
            <summary>
            Sandbox.EntityManager.CreateServerEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_EnttyM_CreateClientsideOfNetworkedEntity(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.EntityManager.CreateClientsideOfNetworkedEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PostCreateInterface">
            <summary>
            Sandbox.GameLoop.PostCreateInterface( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_Init">
            <summary>
            Sandbox.GameLoop.Init( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PreOnActivate">
            <summary>
            Sandbox.GameLoop.PreOnActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PostOnActivate">
            <summary>
            Sandbox.GameLoop.PostOnActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_OnDeactivate">
            <summary>
            Sandbox.GameLoop.OnDeactivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_LoopShutdown">
            <summary>
            Sandbox.GameLoop.LoopShutdown( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_ClientPutInServer(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.GameLoop.ClientPutInServer( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_ClientDisconnected(System.Int32,System.Int32,System.IntPtr,System.UInt64,System.IntPtr)">
            <summary>
            Sandbox.GameLoop.ClientDisconnected( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_OnClientPreOutput">
            <summary>
            Sandbox.GameLoop.OnClientPreOutput( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_OnClientPostOutput">
            <summary>
            Sandbox.GameLoop.OnClientPostOutput( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_GetView(System.IntPtr)">
            <summary>
            Sandbox.GameLoop.GetView( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PreRender">
            <summary>
            Sandbox.GameLoop.PreRender( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PhysicsThink">
            <summary>
            Sandbox.GameLoop.PhysicsThink( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PrePhysicsStep(System.Single)">
            <summary>
            Sandbox.GameLoop.PrePhysicsStep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PostPhysicsStep(System.Single)">
            <summary>
            Sandbox.GameLoop.PostPhysicsStep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PhysicsImpactSound(System.Int32,Vector3,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Sandbox.GameLoop.PhysicsImpactSound( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_OnPhysicsJointBreak(System.Int32)">
            <summary>
            Sandbox.GameLoop.OnPhysicsJointBreak( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_ServerFrame_Think">
            <summary>
            Sandbox.GameLoop.ServerFrame_Think( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_ClientFrame_Think">
            <summary>
            Sandbox.GameLoop.ClientFrame_Think( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Netwrk_OnNetMessage(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sandbox.Networking.OnNetMessage( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_PlyerC_RunClient(System.IntPtr,NativeEngine.CUserCmd)">
            <summary>
            Sandbox.PlayerCommand.RunClient( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_PlyerC_RunServer(System.IntPtr,NativeEngine.CUserCmd)">
            <summary>
            Sandbox.PlayerCommand.RunServer( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_RelTme_Update(System.Single)">
            <summary>
            Sandbox.RealTime.Update( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsBody.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsBody.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_f2(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsGroup.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_f3(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsGroup.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_f4(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsJoint.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_f5(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsJoint.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_f6(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsShape.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_f7(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsShape.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_SceneO_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneObject.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_SceneO_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneObject.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_SceneW_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneWorld.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_SceneW_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneWorld.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_StrngT_Init">
            <summary>
            Sandbox.StringTables.Init( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_StrngT_Shutdown">
            <summary>
            Sandbox.StringTables.Shutdown( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Time_Update(System.Single,System.Single,System.Int32)">
            <summary>
            Sandbox.Time.Update( ... )
            </summary>
        </member>
    </members>
</doc>
